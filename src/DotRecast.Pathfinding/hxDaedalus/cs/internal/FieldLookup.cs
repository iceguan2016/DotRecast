// Generated by Haxe 4.3.6

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.lang {
	public sealed class FieldHashConflict {
		
		public FieldHashConflict(int hash, string name, object @value, global::haxe.lang.FieldHashConflict next) {
			this.hash = hash;
			this.name = name;
			this.@value = @value;
			this.next = next;
		}
		
		
		public readonly int hash;
		
		public readonly string name;
		
		public object @value;
		
		public global::haxe.lang.FieldHashConflict next;
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.lang {
	public sealed class FieldLookup {
		
		#pragma warning disable 628
		static FieldLookup() {
			global::haxe.lang.FieldLookup.length = ( global::haxe.lang.FieldLookup.fieldIds as global::System.Array ).Length;
		}
		
		
		public FieldLookup() {
		}
		
		
		protected static int[] fieldIds = new int[]{97, 98, 99, 100, 101, 102, 120, 121, 21305, 21306, 23515, 4745537, 4747770, 5144726, 5442204, 5594513, 5594516, 5741474, 22110414, 38537191, 57476627, 76061764, 78945784, 85274282, 87367608, 89093622, 104695353, 114842841, 125782329, 131507111, 132121071, 136279361, 142301684, 143015230, 181918579, 190783318, 190783319, 197977816, 200070160, 221637784, 235672157, 238258246, 238260020, 261031087, 278045047, 291546447, 291546448, 302979532, 306638755, 312752480, 328878574, 348377025, 355551430, 359333139, 359360716, 399852413, 402271819, 407283053, 420847906, 437335495, 437571328, 452737314, 456429932, 456429933, 463557661, 480756972, 496602288, 498372011, 501039929, 520590566, 533040171, 537630174, 551064716, 559660363, 562135847, 572311959, 590344996, 630156697, 639965303, 650782251, 659070947, 660583399, 705324505, 708790240, 714931245, 714931246, 722347013, 731985805, 743417354, 746281503, 749558359, 749558360, 764004845, 771456728, 779881113, 787311817, 797170404, 801981566, 808122571, 808122572, 816172375, 833337176, 834174833, 847456158, 863972113, 869793953, 911532223, 913401391, 918006418, 922671056, 924167565, 934361961, 946786476, 956512402, 959399230, 994869407, 995006396, 1002976833, 1007141461, 1009117838, 1009117839, 1020334489, 1029099698, 1033892167, 1059103381, 1059759400, 1067353468, 1076757153, 1076814212, 1103412149, 1120502726, 1122288326, 1125042237, 1167273324, 1169594568, 1177754921, 1179254087, 1181037546, 1184731367, 1184733141, 1198412855, 1204816148, 1209352343, 1214452573, 1224901875, 1228056441, 1230294557, 1233114958, 1247875546, 1247983110, 1253111876, 1253472239, 1257164128, 1260406363, 1262071963, 1273207865, 1275805946, 1280345457, 1280549057, 1280845662, 1282943179, 1283381738, 1299587331, 1304284619, 1311173984, 1313416818, 1323946484, 1344025757, 1352786672, 1360905843, 1373423791, 1385764027, 1392034815, 1395555037, 1398464674, 1404854179, 1416037775, 1431819701, 1436822557, 1450674902, 1458459874, 1460447810, 1461670483, 1462104805, 1468045498, 1468342791, 1502969905, 1507396079, 1512997393, 1532710347, 1537812987, 1541382396, 1547539107, 1596622029, 1620824029, 1621420777, 1623148745, 1639293562, 1648581351, 1656518663, 1658967745, 1664037367, 1686888558, 1692222969, 1704213223, 1705629508, 1707586775, 1724402127, 1741561472, 1745601206, 1747467534, 1761828969, 1762529384, 1763146374, 1768617329, 1771922732, 1776315798, 1779810297, 1804884644, 1813079083, 1816267074, 1818729159, 1825849507, 1827977565, 1830310359, 1838549367, 1840975830, 1876942448, 1882714100, 1891834246, 1898372410, 1900924100, 1915412854, 1916009602, 1926461360, 1937159360, 1946744823, 1976955643, 1978448205, 1981801500, 1981972957, 1999608951, 2020391558, 2022294396, 2024268928, 2025055113, 2026819210, 2044080373, 2044080374, 2048392659, 2049938723, 2049940315, 2049940316, 2053675630, 2054707467, 2057392427, 2070503818, 2072139628, 2072734192, 2077730122, 2078707487, 2078707488, 2082663554, 2088048923, 2100187940, 2106347137, 2127021138, 2133439524, 2135689982, 2137271699, 2137271700, 2143646753, 2143988813};
		
		protected static string[] fields = new string[]{"a", "b", "c", "d", "e", "f", "x", "y", "_x", "_y", "id", "__a", "_id", "get", "map", "pop", "pos", "set", "_constraintShapes", "height", "getEnumConstructs", "remove", "__previousException", "vertexIsInsideAABB", "filter", "updateValuesFromMatrix", "__centerVertex", "_resultEdge", "_resultFace", "set_constraintShape", "deleteVertex", "_originalSeed", "resize", "rotation", "untriangulate", "pivotX", "pivotY", "insertObject", "distanceTo", "__nativeException", "get_width", "_rangeMax", "_rangeMin", "get_length", "__edgesToCheck", "get_x", "get_y", "methodName", "_leftFace", "get_native", "iterator", "set_leftFace", "prevRightEdge", "lastIndexOf", "insertNewConstrainedEdge", "insertVertex", "insertConstraintShape", "hasNext", "rotRightEdge", "message", "_resultVertex", "reverse", "transformX", "transformY", "get_prevRightEdge", "nOccupied", "get_fromConstraintSegments", "get_rotRightEdge", "insert", "length", "deleteConstraintSegment", "get_message", "isConstrained", "get_clipping", "fromFace", "native", "get_id", "array", "fromMesh", "get_pos", "get_isConstrained", "set_originVertex", "_hasChanged", "_matrix", "_scaleX", "_scaleY", "_constraintShape", "normalize", "get_matrix", "contains", "get_scaleX", "get_scaleY", "get_edges", "get___constraintShapes", "rightFace", "_originVertex", "realEdgesOnly", "set_matrix", "set_scaleX", "set_scaleY", "fromShape", "_vertices", "value", "set_coordinates", "__nativeStack", "_clipping", "set_clipping", "_nextEdge", "get_coordinates", "cachedIndex", "_fromVertex", "get_destinationVertex", "toString", "destinationVertex", "identity", "dispose", "hashes", "matrix", "_objects", "scaleX", "scaleY", "deleteConstraintShape", "get_rotLeftEdge", "get_rotation", "_pos", "removeFromConstraintSegment", "splice", "removeEdge", "constraintShape", "copy", "get_edge", "nextRightEdge", "edge", "transform", "check", "__skipStack", "_width", "join", "rangeMax", "rangeMin", "splitEdge", "concat", "splitFace", "clone", "next", "enumConstructor", "get_nextRightEdge", "translate", "push", "width", "leftFace", "set_isConstrained", "keyValueIterator", "rotate", "get_constraintShape", "current", "get_seed", "seed", "size", "sort", "quicksort", "originVertex", "get_hasChanged", "updateObjects", "segments", "vals", "set_nextLeftEdge", "_rotation", "spliceVoid", "get_originVertex", "tranform", "set_rotation", "_numIter", "cachedKey", "getEnumName", "_oppositeEdge", "__constraintShapes", "createEnumIndex", "createEnum", "_nextLeftEdge", "_currSeed", "__ownStack", "debug", "nextInRange", "hasChanged", "_isReal", "get_isReal", "__objectsUpdateInProgress", "posInfos", "concatNative", "nBuckets", "_coordinates", "className", "_isConstrained", "__unsafe_get", "__unsafe_set", "indexOf", "lookup", "fileName", "setDatas", "substract", "prevLeftEdge", "fromVertex", "shuffle", "fromConstraintSegments", "toDynamic", "_edges", "reset", "get_prevLeftEdge", "updateMatrixFromValues", "getVerticesAndEdges", "buildFromRecord", "isReal", "_fromFace", "allEnums", "triangulate", "edges", "vertices", "set_fromFace", "addFromConstraintSegment", "clipping", "restoreAsDelaunay", "unwrap", "insertConstraintSegment", "customParams", "set_hasChanged", "_fromMesh", "get_rightFace", "set_fromMesh", "_height", "set_edge", "oppositeEdge", "__get", "__set", "get_height", "__hx_deleteField", "nextLeftEdge", "coordinates", "get_oppositeEdge", "_edge", "lineNumber", "_faces", "_fromConstraintSegments", "upperBound", "get_nextLeftEdge", "unshift", "scale", "_pivotX", "_pivotY", "_keys", "setXY", "set_x", "set_y", "set_seed", "enumParameters", "set_fromVertex", "flipEdge", "set_datas", "colorDebug", "deleteObject", "get_pivotX", "get_pivotY", "shift", "rotLeftEdge", "set_fromConstraintSegments", "_currIndex", "slice", "_tempString", "addEdge", "set_pivotX", "set_pivotY", "findPositionFromBounds", "get_leftFace"};
		
		protected static int length;
		
		public static void addFields(int[] nids, string[] nfields) {
			unchecked {
				int[] cids = global::haxe.lang.FieldLookup.fieldIds;
				string[] cfields = global::haxe.lang.FieldLookup.fields;
				int nlen = ( nids as global::System.Array ).Length;
				int clen = global::haxe.lang.FieldLookup.length;
				if (( ( nfields as global::System.Array ).Length != nlen )) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("Different fields length: ", global::haxe.lang.Runtime.toString(nlen)), " and "), global::haxe.lang.Runtime.toString(( nfields as global::System.Array ).Length)))) );
				}
				
				bool needsChange = false;
				{
					int[] _g_arr = nids;
					uint _g_idx = ((uint) (0) );
					while (( _g_idx < ( _g_arr as global::System.Array ).Length )) {
						_g_idx += ((uint) (1) );
						int i = _g_arr[((int) (((uint) (( _g_idx - 1 )) )) )];
						if (( global::haxe.lang.FieldLookup.findHash(i, cids, clen) < 0 )) {
							needsChange = true;
							break;
						}
						
					}
					
				}
				
				if (needsChange) {
					lock(typeof(global::haxe.lang.FieldLookup)){
						int[] ansIds = new int[( clen + nlen )];
						string[] ansFields = new string[( clen + nlen )];
						int ci = 0;
						int ni = 0;
						int ansi = 0;
						while (true) {
							if ( ! ((( (( ci < clen )) ? (( ni < nlen )) : (false) ))) ) {
								break;
							}
							
							if (( cids[ci] < nids[ni] )) {
								ansIds[ansi] = cids[ci];
								ansFields[ansi] = ((string) (cfields[ci]) );
								ci = ( ci + 1 );
							}
							else {
								ansIds[ansi] = nids[ni];
								ansFields[ansi] = ((string) (nfields[ni]) );
								ni = ( ni + 1 );
							}
							
							ansi = ( ansi + 1 );
						}
						
						if (( ci < clen )) {
							global::System.Array.Copy(((global::System.Array) (cids) ), ((int) (ci) ), ((global::System.Array) (ansIds) ), ((int) (ansi) ), ((int) (( clen - ci )) ));
							global::System.Array.Copy(((global::System.Array) (cfields) ), ((int) (ci) ), ((global::System.Array) (ansFields) ), ((int) (ansi) ), ((int) (( clen - ci )) ));
							ansi = ( ansi + (( clen - ci )) );
						}
						
						if (( ni < nlen )) {
							global::System.Array.Copy(((global::System.Array) (nids) ), ((int) (ni) ), ((global::System.Array) (ansIds) ), ((int) (ansi) ), ((int) (( nlen - ni )) ));
							global::System.Array.Copy(((global::System.Array) (nfields) ), ((int) (ni) ), ((global::System.Array) (ansFields) ), ((int) (ansi) ), ((int) (( nlen - ni )) ));
							ansi = ( ansi + (( nlen - ni )) );
						}
						
						global::haxe.lang.FieldLookup.fieldIds = ansIds;
						global::haxe.lang.FieldLookup.fields = ansFields;
						global::haxe.lang.FieldLookup.length = ansi;
					}
					;
				}
				
			}
		}
		
		
		public static int doHash(string s) {
			unchecked {
				int acc = 0;
				{
					int _g = 0;
					int _g1 = s.Length;
					while (( _g < _g1 )) {
						int i = _g++;
						acc = ( ( ( 223 * (( acc >> 1 )) ) + ((int) (s[i]) ) ) << 1 );
					}
					
				}
				
				return ((int) (( ((uint) (acc) ) >> 1 )) );
			}
		}
		
		
		public static string lookupHash(int key) {
			unchecked {
				int[] ids = global::haxe.lang.FieldLookup.fieldIds;
				int min = 0;
				int max = global::haxe.lang.FieldLookup.length;
				while (( min < max )) {
					int mid = ( min + ( (( max - min )) / 2 ) );
					int imid = ids[mid];
					if (( key < imid )) {
						max = mid;
					}
					else if (( key > imid )) {
						min = ( mid + 1 );
					}
					else {
						return ((string) (global::haxe.lang.FieldLookup.fields[mid]) );
					}
					
				}
				
				throw ((global::System.Exception) (global::haxe.Exception.thrown(global::haxe.lang.Runtime.concat("Field not found for hash ", global::haxe.lang.Runtime.toString(key)))) );
			}
		}
		
		
		public static int hash(string s) {
			unchecked {
				if (( s == null )) {
					return 0;
				}
				
				int acc = 0;
				{
					int _g = 0;
					int _g1 = s.Length;
					while (( _g < _g1 )) {
						int i = _g++;
						acc = ( ( ( 223 * (( acc >> 1 )) ) + ((int) (s[i]) ) ) << 1 );
					}
					
				}
				
				int key = ((int) (( ((uint) (acc) ) >> 1 )) );
				int[] ids = global::haxe.lang.FieldLookup.fieldIds;
				string[] fld = global::haxe.lang.FieldLookup.fields;
				int min = 0;
				int max = global::haxe.lang.FieldLookup.length;
				int len = global::haxe.lang.FieldLookup.length;
				while (( min < max )) {
					int mid = ((int) (( min + ( ((double) ((( max - min ))) ) / 2 ) )) );
					int imid = ids[mid];
					if (( key < imid )) {
						max = mid;
					}
					else if (( key > imid )) {
						min = ( mid + 1 );
					}
					else {
						string field = ((string) (fld[mid]) );
						if (( field != s )) {
							return  ~ (key) ;
						}
						
						return key;
					}
					
				}
				
				lock(typeof(global::haxe.lang.FieldLookup)){
					if (( len != global::haxe.lang.FieldLookup.length )) {
						return global::haxe.lang.FieldLookup.hash(s);
					}
					
					global::haxe.lang.FieldLookup.fieldIds = global::haxe.lang.FieldLookup.insertInt(global::haxe.lang.FieldLookup.fieldIds, global::haxe.lang.FieldLookup.length, min, key);
					global::haxe.lang.FieldLookup.fields = global::haxe.lang.FieldLookup.insertString(global::haxe.lang.FieldLookup.fields, global::haxe.lang.FieldLookup.length, min, s);
					 ++ global::haxe.lang.FieldLookup.length;
				}
				;
				return key;
			}
		}
		
		
		public static int findHash(int hash, int[] hashs, int length) {
			unchecked {
				int min = 0;
				int max = length;
				while (( min < max )) {
					int mid = ( (( max + min )) / 2 );
					int imid = hashs[mid];
					if (( hash < imid )) {
						max = mid;
					}
					else if (( hash > imid )) {
						min = ( mid + 1 );
					}
					else {
						return mid;
					}
					
				}
				
				return  ~ (min) ;
			}
		}
		
		
		public static void removeInt(int[] a, int length, int pos) {
			unchecked {
				global::System.Array.Copy(((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((global::System.Array) (a) ), ((int) (pos) ), ((int) (( ( length - pos ) - 1 )) ));
				a[( length - 1 )] = 0;
			}
		}
		
		
		public static void removeFloat(double[] a, int length, int pos) {
			unchecked {
				global::System.Array.Copy(((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((global::System.Array) (a) ), ((int) (pos) ), ((int) (( ( length - pos ) - 1 )) ));
				a[( length - 1 )] = ((double) (0) );
			}
		}
		
		
		public static void removeDynamic(object[] a, int length, int pos) {
			unchecked {
				global::System.Array.Copy(((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((global::System.Array) (a) ), ((int) (pos) ), ((int) (( ( length - pos ) - 1 )) ));
				a[( length - 1 )] = null;
			}
		}
		
		
		public static int[] insertInt(int[] a, int length, int pos, int x) {
			unchecked {
				int[] a1 = a;
				int capacity = ( a1 as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						int[] newarr = new int[( (( length << 1 )) + 1 )];
						( a1 as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a1 = newarr;
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						int[] newarr1 = new int[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a1 = newarr1;
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					int[] newarr2 = new int[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a1 = newarr2;
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (a1) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a1[pos] = x;
				return a1;
			}
		}
		
		
		public static double[] insertFloat(double[] a, int length, int pos, double x) {
			unchecked {
				double[] a1 = a;
				int capacity = ( a1 as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						double[] newarr = new double[( (( length << 1 )) + 1 )];
						( a1 as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a1 = newarr;
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						double[] newarr1 = new double[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a1 = newarr1;
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					double[] newarr2 = new double[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a1 = newarr2;
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (a1) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a1[pos] = x;
				return a1;
			}
		}
		
		
		public static object[] insertDynamic(object[] a, int length, int pos, object x) {
			unchecked {
				object[] a1 = a;
				int capacity = ( a1 as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						object[] newarr = new object[( (( length << 1 )) + 1 )];
						( a1 as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a1 = newarr;
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						object[] newarr1 = new object[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a1 = newarr1;
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					object[] newarr2 = new object[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a1 = newarr2;
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (a1) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a1[pos] = ((object) (x) );
				return a1;
			}
		}
		
		
		public static string[] insertString(string[] a, int length, int pos, string x) {
			unchecked {
				string[] a1 = a;
				int capacity = ( a1 as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						string[] newarr = new string[( (( length << 1 )) + 1 )];
						( a1 as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a1 = newarr;
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						string[] newarr1 = new string[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a1 = newarr1;
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					string[] newarr2 = new string[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a1 = newarr2;
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (a1) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a1[pos] = x;
				return a1;
			}
		}
		
		
		public static global::haxe.lang.FieldHashConflict getHashConflict(global::haxe.lang.FieldHashConflict head, int hash, string name) {
			while (( head != null )) {
				if (( ( head.hash == hash ) && ( head.name == name ) )) {
					return head;
				}
				
				head = head.next;
			}
			
			return null;
		}
		
		
		public static void setHashConflict(ref global::haxe.lang.FieldHashConflict head, int hash, string name, object @value) {
			global::haxe.lang.FieldHashConflict node = head;
			while (( node != null )) {
				if (( ( node.hash == hash ) && ( node.name == name ) )) {
					node.@value = @value;
					return;
				}
				
				node = ((global::haxe.lang.FieldHashConflict) (node.next) );
			}
			
			head = ((global::haxe.lang.FieldHashConflict) (new global::haxe.lang.FieldHashConflict(hash, name, @value, ((global::haxe.lang.FieldHashConflict) (head) ))) );
		}
		
		
		public static bool deleteHashConflict(ref global::haxe.lang.FieldHashConflict head, int hash, string name) {
			if (( head == null )) {
				return false;
			}
			
			if (( ( head.hash == hash ) && ( head.name == name ) )) {
				head = ((global::haxe.lang.FieldHashConflict) (head.next) );
				return true;
			}
			
			global::haxe.lang.FieldHashConflict prev = head;
			global::haxe.lang.FieldHashConflict node = head.next;
			while (( node != null )) {
				if (( ( node.hash == hash ) && ( node.name == name ) )) {
					prev.next = node.next;
					return true;
				}
				
				node = node.next;
			}
			
			return false;
		}
		
		
		public static void addHashConflictNames(global::haxe.lang.FieldHashConflict head, global::HxArray<string> arr) {
			while (( head != null )) {
				arr.push(head.name);
				head = head.next;
			}
			
		}
		
		
	}
}


