// Generated by Haxe 4.3.6

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace hxDaedalus.ai {
	public class AStar : global::haxe.lang.HxObject {
		
		public AStar(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public AStar() {
			global::hxDaedalus.ai.AStar.__hx_ctor_hxDaedalus_ai_AStar(this);
		}
		
		
		protected static void __hx_ctor_hxDaedalus_ai_AStar(global::hxDaedalus.ai.AStar __hx_this) {
			__hx_this.iterEdge = new global::hxDaedalus.iterators.FromFaceToInnerEdges();
		}
		
		
		
		
		public double _radius;
		
		
		
		public global::hxDaedalus.data.Mesh _mesh;
		
		public global::haxe.ds.ObjectMap<object, bool> closedFaces;
		
		public global::HxArray<object> sortedOpenedFaces;
		
		public global::haxe.ds.ObjectMap<object, object> openedFaces;
		
		public global::haxe.ds.ObjectMap<object, object> entryEdges;
		
		public global::haxe.ds.ObjectMap<object, double> entryX;
		
		public global::haxe.ds.ObjectMap<object, double> entryY;
		
		public global::haxe.ds.ObjectMap<object, double> scoreF;
		
		public global::haxe.ds.ObjectMap<object, double> scoreG;
		
		public global::haxe.ds.ObjectMap<object, double> scoreH;
		
		public global::haxe.ds.ObjectMap<object, object> predecessor;
		
		public global::hxDaedalus.iterators.FromFaceToInnerEdges iterEdge;
		
		public double radiusSquared;
		
		public double diameter;
		
		public double diameterSquared;
		
		public global::hxDaedalus.data.Face fromFace;
		
		public global::hxDaedalus.data.Face toFace;
		
		public global::hxDaedalus.data.Face curFace;
		
		public virtual void dispose() {
			this._mesh = null;
			this.closedFaces = null;
			this.sortedOpenedFaces = null;
			this.openedFaces = null;
			this.entryEdges = null;
			this.entryX = null;
			this.entryY = null;
			this.scoreF = null;
			this.scoreG = null;
			this.scoreH = null;
			this.predecessor = null;
		}
		
		
		public virtual double get_radius() {
			return this._radius;
		}
		
		
		public virtual double set_radius(double @value) {
			unchecked {
				this._radius = @value;
				this.radiusSquared = ( this._radius * this._radius );
				this.diameter = ( this._radius * 2 );
				this.diameterSquared = ( this.diameter * this.diameter );
				return @value;
			}
		}
		
		
		public virtual global::hxDaedalus.data.Mesh set_mesh(global::hxDaedalus.data.Mesh @value) {
			this._mesh = @value;
			return @value;
		}
		
		
		public virtual void findPath(double fromX, double fromY, double toX, double toY, global::HxArray<object> resultListFaces, global::HxArray<object> resultListEdges) {
			unchecked {
				this.closedFaces = new global::haxe.ds.ObjectMap<object, bool>();
				this.sortedOpenedFaces = new global::HxArray<object>();
				this.openedFaces = ((global::haxe.ds.ObjectMap<object, object>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, object>(((global::haxe.ds.ObjectMap) (new global::haxe.ds.ObjectMap<object, bool>()) ))) );
				this.entryEdges = new global::haxe.ds.ObjectMap<object, object>();
				this.entryX = new global::haxe.ds.ObjectMap<object, double>();
				this.entryY = new global::haxe.ds.ObjectMap<object, double>();
				this.scoreF = new global::haxe.ds.ObjectMap<object, double>();
				this.scoreG = new global::haxe.ds.ObjectMap<object, double>();
				this.scoreH = new global::haxe.ds.ObjectMap<object, double>();
				this.predecessor = new global::haxe.ds.ObjectMap<object, object>();
				global::hxDaedalus.data.Edge locEdge = null;
				global::hxDaedalus.data.Vertex locVertex = null;
				double distance = default(double);
				global::hxDaedalus.data.math.Point2D p1 = null;
				global::hxDaedalus.data.math.Point2D p2 = null;
				global::hxDaedalus.data.math.Point2D p3 = null;
				global::hxDaedalus.data.math.Intersection loc = global::hxDaedalus.data.math.Geom2D.locatePosition(fromX, fromY, this._mesh);
				switch (loc._hx_index) {
					case 0:
					{
						global::hxDaedalus.data.Vertex vertex = ( loc as global::hxDaedalus.data.math.Intersection_EVertex ).vertex;
						locVertex = vertex;
						return;
					}
					
					
					case 1:
					{
						global::hxDaedalus.data.Edge edge = ( loc as global::hxDaedalus.data.math.Intersection_EEdge ).edge;
						{
							locEdge = edge;
							if (locEdge.get_isConstrained()) {
								return;
							}
							
							this.fromFace = locEdge.get_leftFace();
						}
						
						break;
					}
					
					
					case 2:
					{
						global::hxDaedalus.data.Face face = ( loc as global::hxDaedalus.data.math.Intersection_EFace ).face;
						this.fromFace = face;
						break;
					}
					
					
					case 3:
					{
						break;
					}
					
					
				}
				
				loc = global::hxDaedalus.data.math.Geom2D.locatePosition(toX, toY, this._mesh);
				switch (loc._hx_index) {
					case 0:
					{
						global::hxDaedalus.data.Vertex vertex1 = ( loc as global::hxDaedalus.data.math.Intersection_EVertex ).vertex;
						{
							locVertex = vertex1;
							this.toFace = locVertex.get_edge().get_leftFace();
						}
						
						break;
					}
					
					
					case 1:
					{
						global::hxDaedalus.data.Edge edge1 = ( loc as global::hxDaedalus.data.math.Intersection_EEdge ).edge;
						{
							locEdge = edge1;
							this.toFace = locEdge.get_leftFace();
						}
						
						break;
					}
					
					
					case 2:
					{
						global::hxDaedalus.data.Face face1 = ( loc as global::hxDaedalus.data.math.Intersection_EFace ).face;
						this.toFace = face1;
						break;
					}
					
					
					case 3:
					{
						break;
					}
					
					
				}

				this.sortedOpenedFaces.push(this.fromFace);
				{
					global::hxDaedalus.data.Edge v = null;
					((global::haxe.ds.ObjectMap<object, object>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, object>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, object>) (this.entryEdges) )) ))) ).@set(this.fromFace, v);
				}
				
				((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, double>) (this.entryX) )) ))) ).@set(this.fromFace, fromX);
				((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, double>) (this.entryY) )) ))) ).@set(this.fromFace, fromY);
				((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, double>) (this.scoreG) )) ))) ).@set(this.fromFace, ((double) (0) ));
				double dist = global::System.Math.Sqrt(((double) (( ( (( toX - fromX )) * (( toX - fromX )) ) + ( (( toY - fromY )) * (( toY - fromY )) ) )) ));
				((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, double>) (this.scoreH) )) ))) ).@set(this.fromFace, dist);
				((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, double>) (this.scoreF) )) ))) ).@set(this.fromFace, dist);
				global::hxDaedalus.data.Edge innerEdge = null;
				global::hxDaedalus.data.Face neighbourFace = null;
				double f = default(double);
				double g = default(double);
				double h = default(double);
				global::hxDaedalus.data.math.Point2D fromPoint = new global::hxDaedalus.data.math.Point2D(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
				global::hxDaedalus.data.math.Point2D entryPoint = new global::hxDaedalus.data.math.Point2D(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
				global::hxDaedalus.data.math.Point2D distancePoint = new global::hxDaedalus.data.math.Point2D(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
				bool fillDatas = default(bool);
				while (true) {
					if (( this.sortedOpenedFaces.length == 0 )) {
						this.curFace = null;
						break;
					}
					
					this.curFace = ((global::hxDaedalus.data.Face) ((this.sortedOpenedFaces.pop()).@value) );
					if (( this.curFace == this.toFace )) {
						break;
					}
					
					this.iterEdge.set_fromFace(this.curFace);
					while (true) {
						innerEdge = this.iterEdge.next();
						if ( ! ((( innerEdge != null ))) ) {
							break;
						}
						
						if (innerEdge.get_isConstrained()) {
							continue;
						}
						
						neighbourFace = innerEdge.get_rightFace();
						if (( ! ((((global::haxe.ds.ObjectMap<object, bool>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, bool>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, bool>) (this.closedFaces) )) ))) ).@get(neighbourFace)).@value) )) {
							if (( ( ( this.curFace != this.fromFace ) && ( this._radius > 0 ) ) &&  ! (this.isWalkableByRadius(((global::hxDaedalus.data.Edge) ((((global::haxe.ds.ObjectMap<object, object>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, object>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, object>) (this.entryEdges) )) ))) ).@get(this.curFace)).@value) ), this.curFace, innerEdge))  )) {
								continue;
							}
							
							fromPoint.x = (((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, double>) (this.entryX) )) ))) ).@get(this.curFace)).@value;
							fromPoint.y = (((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, double>) (this.entryY) )) ))) ).@get(this.curFace)).@value;
							entryPoint.x = ( (( innerEdge.get_originVertex().get_pos().x + innerEdge.get_destinationVertex().get_pos().x )) / 2 );
							entryPoint.y = ( (( innerEdge.get_originVertex().get_pos().y + innerEdge.get_destinationVertex().get_pos().y )) / 2 );
							distancePoint.x = ( entryPoint.x - toX );
							distancePoint.y = ( entryPoint.y - toY );
							h = distancePoint.get_length();
							distancePoint.x = ( fromPoint.x - entryPoint.x );
							distancePoint.y = ( fromPoint.y - entryPoint.y );
							g = ( (((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, double>) (this.scoreG) )) ))) ).@get(this.curFace)).@value + distancePoint.get_length() );
							f = ( h + g );
							fillDatas = false;
							global::haxe.lang.Null<object> __temp_nulltmp1 = default(global::haxe.lang.Null<object>);
							if ((  ! (( ((__temp_nulltmp1 = ((global::haxe.ds.ObjectMap<object, object>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, object>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, object>) (this.openedFaces) )) ))) ).@get(neighbourFace)).hasValue) ? (new global::haxe.lang.Null<bool>(global::haxe.lang.Runtime.toBool((__temp_nulltmp1).@value), true)) : (new global::haxe.lang.Null<bool>(default(bool), false)) ).hasValue)  || ( ! (global::haxe.lang.Runtime.toBool((((global::haxe.ds.ObjectMap<object, object>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, object>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, object>) (this.openedFaces) )) ))) ).@get(neighbourFace)).@value)) ) )) {
								this.sortedOpenedFaces.push(neighbourFace);
								((global::haxe.ds.ObjectMap<object, object>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, object>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, object>) (this.openedFaces) )) ))) ).@set(neighbourFace, true);
								fillDatas = true;
							}
							else if (( (((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, double>) (this.scoreF) )) ))) ).@get(neighbourFace)).@value > f )) {
								fillDatas = true;
							}
							
							if (fillDatas) {
								((global::haxe.ds.ObjectMap<object, object>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, object>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, object>) (this.entryEdges) )) ))) ).@set(neighbourFace, innerEdge);
								{
									double v1 = entryPoint.x;
									((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, double>) (this.entryX) )) ))) ).@set(neighbourFace, v1);
								}
								
								{
									double v2 = entryPoint.y;
									((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, double>) (this.entryY) )) ))) ).@set(neighbourFace, v2);
								}
								
								((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, double>) (this.scoreF) )) ))) ).@set(neighbourFace, f);
								((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, double>) (this.scoreG) )) ))) ).@set(neighbourFace, g);
								((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, double>) (this.scoreH) )) ))) ).@set(neighbourFace, h);
								{
									global::hxDaedalus.data.Face v3 = this.curFace;
									((global::haxe.ds.ObjectMap<object, object>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, object>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, object>) (this.predecessor) )) ))) ).@set(neighbourFace, v3);
								}
								
							}
							
						}
						
					}
					
					((global::haxe.ds.ObjectMap<object, object>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, object>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, object>) (this.openedFaces) )) ))) ).@set(this.curFace, false);
					((global::haxe.ds.ObjectMap<object, bool>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, bool>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, bool>) (this.closedFaces) )) ))) ).@set(this.curFace, true);
					this.sortedOpenedFaces.sort(((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "sortingFaces", 824015442)) ));
				}
				
				if (( this.curFace == null )) {
					return;
				}
				
				resultListFaces.push(this.curFace);
				while (( this.curFace != this.fromFace )) {
					resultListEdges.unshift(((global::hxDaedalus.data.Edge) ((((global::haxe.ds.ObjectMap<object, object>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, object>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, object>) (this.entryEdges) )) ))) ).@get(this.curFace)).@value) ));
					this.curFace = ((global::hxDaedalus.data.Face) ((((global::haxe.ds.ObjectMap<object, object>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, object>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, object>) (this.predecessor) )) ))) ).@get(this.curFace)).@value) );
					resultListFaces.unshift(this.curFace);
				}
				
			}
		}
		
		
		public virtual int sortingFaces(global::hxDaedalus.data.Face a, global::hxDaedalus.data.Face b) {
			unchecked {
				if (global::haxe.lang.Runtime.eq((((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, double>) (this.scoreF) )) ))) ).@get(a)).toDynamic(), (((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, double>) (this.scoreF) )) ))) ).@get(b)).toDynamic())) {
					return 0;
				}
				else if (( (((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, double>) (this.scoreF) )) ))) ).@get(a)).@value < (((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (((global::haxe.IMap<object, double>) (this.scoreF) )) ))) ).@get(b)).@value )) {
					return 1;
				}
				else {
					return -1;
				}
				
			}
		}
		
		
		public virtual bool isWalkableByRadius(global::hxDaedalus.data.Edge fromEdge, global::hxDaedalus.data.Face throughFace, global::hxDaedalus.data.Edge toEdge) {
			global::hxDaedalus.data.Vertex vA = null;
			global::hxDaedalus.data.Vertex vB = null;
			global::hxDaedalus.data.Vertex vC = null;
			if (( fromEdge.get_originVertex() == toEdge.get_originVertex() )) {
				vA = fromEdge.get_destinationVertex();
				vB = toEdge.get_destinationVertex();
				vC = fromEdge.get_originVertex();
			}
			else if (( fromEdge.get_destinationVertex() == toEdge.get_destinationVertex() )) {
				vA = fromEdge.get_originVertex();
				vB = toEdge.get_originVertex();
				vC = fromEdge.get_destinationVertex();
			}
			else if (( fromEdge.get_originVertex() == toEdge.get_destinationVertex() )) {
				vA = fromEdge.get_destinationVertex();
				vB = toEdge.get_originVertex();
				vC = fromEdge.get_originVertex();
			}
			else if (( fromEdge.get_destinationVertex() == toEdge.get_originVertex() )) {
				vA = fromEdge.get_originVertex();
				vB = toEdge.get_destinationVertex();
				vC = fromEdge.get_destinationVertex();
			}
			
			bool result = default(bool);
			double distSquared = default(double);
			double dot = ( ( (( vC.get_pos().x - vA.get_pos().x )) * (( vB.get_pos().x - vA.get_pos().x )) ) + ( (( vC.get_pos().y - vA.get_pos().y )) * (( vB.get_pos().y - vA.get_pos().y )) ) );
			if (( dot <= 0 )) {
				distSquared = ( ( (( vC.get_pos().x - vA.get_pos().x )) * (( vC.get_pos().x - vA.get_pos().x )) ) + ( (( vC.get_pos().y - vA.get_pos().y )) * (( vC.get_pos().y - vA.get_pos().y )) ) );
				if (( distSquared >= this.diameterSquared )) {
					return true;
				}
				else {
					return false;
				}
				
			}
			
			dot = ( ( (( vC.get_pos().x - vB.get_pos().x )) * (( vA.get_pos().x - vB.get_pos().x )) ) + ( (( vC.get_pos().y - vB.get_pos().y )) * (( vA.get_pos().y - vB.get_pos().y )) ) );
			if (( dot <= 0 )) {
				distSquared = ( ( (( vC.get_pos().x - vB.get_pos().x )) * (( vC.get_pos().x - vB.get_pos().x )) ) + ( (( vC.get_pos().y - vB.get_pos().y )) * (( vC.get_pos().y - vB.get_pos().y )) ) );
				if (( distSquared >= this.diameterSquared )) {
					return true;
				}
				else {
					return false;
				}
				
			}
			
			global::hxDaedalus.data.Edge adjEdge = null;
			if (( ( ( ( throughFace.get_edge() != fromEdge ) && ( throughFace.get_edge().get_oppositeEdge() != fromEdge ) ) && ( throughFace.get_edge() != toEdge ) ) && ( throughFace.get_edge().get_oppositeEdge() != toEdge ) )) {
				adjEdge = throughFace.get_edge();
			}
			else if (( ( ( ( throughFace.get_edge().get_nextLeftEdge() != fromEdge ) && ( throughFace.get_edge().get_nextLeftEdge().get_oppositeEdge() != fromEdge ) ) && ( throughFace.get_edge().get_nextLeftEdge() != toEdge ) ) && ( throughFace.get_edge().get_nextLeftEdge().get_oppositeEdge() != toEdge ) )) {
				adjEdge = throughFace.get_edge().get_nextLeftEdge();
			}
			else {
				adjEdge = throughFace.get_edge().get_prevLeftEdge();
			}
			
			if (adjEdge.get_isConstrained()) {
				global::hxDaedalus.data.math.Point2D proj = new global::hxDaedalus.data.math.Point2D(new global::haxe.lang.Null<double>(vC.get_pos().x, true), new global::haxe.lang.Null<double>(vC.get_pos().y, true));
				global::hxDaedalus.data.math.Geom2D.projectOrthogonaly(proj, adjEdge);
				distSquared = ( ( (( proj.x - vC.get_pos().x )) * (( proj.x - vC.get_pos().x )) ) + ( (( proj.y - vC.get_pos().y )) * (( proj.y - vC.get_pos().y )) ) );
				if (( distSquared >= this.diameterSquared )) {
					return true;
				}
				else {
					return false;
				}
				
			}
			else {
				double distSquaredA = ( ( (( vC.get_pos().x - vA.get_pos().x )) * (( vC.get_pos().x - vA.get_pos().x )) ) + ( (( vC.get_pos().y - vA.get_pos().y )) * (( vC.get_pos().y - vA.get_pos().y )) ) );
				double distSquaredB = ( ( (( vC.get_pos().x - vB.get_pos().x )) * (( vC.get_pos().x - vB.get_pos().x )) ) + ( (( vC.get_pos().y - vB.get_pos().y )) * (( vC.get_pos().y - vB.get_pos().y )) ) );
				if (( ( distSquaredA < this.diameterSquared ) || ( distSquaredB < this.diameterSquared ) )) {
					return false;
				}
				else {
					global::HxArray<object> vFaceToCheck = new global::HxArray<object>();
					global::HxArray<object> vFaceIsFromEdge = new global::HxArray<object>();
					global::haxe.ds.ObjectMap<object, bool> facesDone = new global::haxe.ds.ObjectMap<object, bool>();
					vFaceIsFromEdge.push(adjEdge);
					if (( adjEdge.get_leftFace() == throughFace )) {
						vFaceToCheck.push(adjEdge.get_rightFace());
						facesDone.@set(adjEdge.get_rightFace(), true);
					}
					else {
						vFaceToCheck.push(adjEdge.get_leftFace());
						facesDone.@set(adjEdge.get_leftFace(), true);
					}
					
					global::hxDaedalus.data.Face currFace = null;
					global::hxDaedalus.data.Edge faceFromEdge = null;
					global::hxDaedalus.data.Edge currEdgeA = null;
					global::hxDaedalus.data.Face nextFaceA = null;
					global::hxDaedalus.data.Edge currEdgeB = null;
					global::hxDaedalus.data.Face nextFaceB = null;
					while (( vFaceToCheck.length > 0 )) {
						currFace = ((global::hxDaedalus.data.Face) ((vFaceToCheck.shift()).@value) );
						faceFromEdge = ((global::hxDaedalus.data.Edge) ((vFaceIsFromEdge.shift()).@value) );
						if (( ( currFace.get_edge() == faceFromEdge ) || ( currFace.get_edge() == faceFromEdge.get_oppositeEdge() ) )) {
							currEdgeA = currFace.get_edge().get_nextLeftEdge();
							currEdgeB = currFace.get_edge().get_nextLeftEdge().get_nextLeftEdge();
						}
						else if (( ( currFace.get_edge().get_nextLeftEdge() == faceFromEdge ) || ( currFace.get_edge().get_nextLeftEdge() == faceFromEdge.get_oppositeEdge() ) )) {
							currEdgeA = currFace.get_edge();
							currEdgeB = currFace.get_edge().get_nextLeftEdge().get_nextLeftEdge();
						}
						else {
							currEdgeA = currFace.get_edge();
							currEdgeB = currFace.get_edge().get_nextLeftEdge();
						}
						
						if (( currEdgeA.get_leftFace() == currFace )) {
							nextFaceA = currEdgeA.get_rightFace();
						}
						else {
							nextFaceA = currEdgeA.get_leftFace();
						}
						
						if (( currEdgeB.get_leftFace() == currFace )) {
							nextFaceB = currEdgeB.get_rightFace();
						}
						else {
							nextFaceB = currEdgeB.get_leftFace();
						}
						
						if (( ( ! ((facesDone.@get(nextFaceA)).@value) ) && ( global::hxDaedalus.data.math.Geom2D.distanceSquaredVertexToEdge(vC, currEdgeA) < this.diameterSquared ) )) {
							if (currEdgeA.get_isConstrained()) {
								return false;
							}
							else {
								vFaceToCheck.push(nextFaceA);
								vFaceIsFromEdge.push(currEdgeA);
								facesDone.@set(nextFaceA, true);
							}
							
						}
						
						if (( ( ! ((facesDone.@get(nextFaceB)).@value) ) && ( global::hxDaedalus.data.math.Geom2D.distanceSquaredVertexToEdge(vC, currEdgeB) < this.diameterSquared ) )) {
							if (currEdgeB.get_isConstrained()) {
								return false;
							}
							else {
								vFaceToCheck.push(nextFaceB);
								vFaceIsFromEdge.push(currEdgeB);
								facesDone.@set(nextFaceB, true);
							}
							
						}
						
					}
					
					return true;
				}
				
			}
			
		}
		
		
		public override double __hx_setField_f(string field, int hash, double @value, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 1797678554:
					{
						this.diameterSquared = ((double) (@value) );
						return @value;
					}
					
					
					case 879259341:
					{
						this.diameter = ((double) (@value) );
						return @value;
					}
					
					
					case 281767669:
					{
						this.radiusSquared = ((double) (@value) );
						return @value;
					}
					
					
					case 527294961:
					{
						this._radius = ((double) (@value) );
						return @value;
					}
					
					
					case 821481554:
					{
						this.set_radius(@value);
						return @value;
					}
					
					
					default:
					{
						return base.__hx_setField_f(field, hash, @value, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_setField(string field, int hash, object @value, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 785065533:
					{
						this.curFace = ((global::hxDaedalus.data.Face) (@value) );
						return @value;
					}
					
					
					case 2037325752:
					{
						this.toFace = ((global::hxDaedalus.data.Face) (@value) );
						return @value;
					}
					
					
					case 562135847:
					{
						this.fromFace = ((global::hxDaedalus.data.Face) (@value) );
						return @value;
					}
					
					
					case 1797678554:
					{
						this.diameterSquared = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					case 879259341:
					{
						this.diameter = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					case 281767669:
					{
						this.radiusSquared = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					case 17573237:
					{
						this.iterEdge = ((global::hxDaedalus.iterators.FromFaceToInnerEdges) (@value) );
						return @value;
					}
					
					
					case 76261065:
					{
						this.predecessor = ((global::haxe.ds.ObjectMap<object, object>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, object>(((global::haxe.ds.ObjectMap) (@value) ))) );
						return @value;
					}
					
					
					case 1164670134:
					{
						this.scoreH = ((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (@value) ))) );
						return @value;
					}
					
					
					case 1164670133:
					{
						this.scoreG = ((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (@value) ))) );
						return @value;
					}
					
					
					case 1164670132:
					{
						this.scoreF = ((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (@value) ))) );
						return @value;
					}
					
					
					case 86174631:
					{
						this.entryY = ((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (@value) ))) );
						return @value;
					}
					
					
					case 86174630:
					{
						this.entryX = ((global::haxe.ds.ObjectMap<object, double>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, double>(((global::haxe.ds.ObjectMap) (@value) ))) );
						return @value;
					}
					
					
					case 1321437124:
					{
						this.entryEdges = ((global::haxe.ds.ObjectMap<object, object>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, object>(((global::haxe.ds.ObjectMap) (@value) ))) );
						return @value;
					}
					
					
					case 1074666957:
					{
						this.openedFaces = ((global::haxe.ds.ObjectMap<object, object>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, object>(((global::haxe.ds.ObjectMap) (@value) ))) );
						return @value;
					}
					
					
					case 402203024:
					{
						this.sortedOpenedFaces = ((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (@value) ))) );
						return @value;
					}
					
					
					case 266439658:
					{
						this.closedFaces = ((global::haxe.ds.ObjectMap<object, bool>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, bool>(((global::haxe.ds.ObjectMap) (@value) ))) );
						return @value;
					}
					
					
					case 2070570444:
					{
						this._mesh = ((global::hxDaedalus.data.Mesh) (@value) );
						return @value;
					}
					
					
					case 1213811181:
					{
						this.set_mesh(((global::hxDaedalus.data.Mesh) (@value) ));
						return @value;
					}
					
					
					case 527294961:
					{
						this._radius = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					case 821481554:
					{
						this.set_radius(((double) (global::haxe.lang.Runtime.toDouble(@value)) ));
						return @value;
					}
					
					
					default:
					{
						return base.__hx_setField(field, hash, @value, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_getField(string field, int hash, bool throwErrors, bool isCheck, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 794155990:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "isWalkableByRadius", 794155990)) );
					}
					
					
					case 824015442:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "sortingFaces", 824015442)) );
					}
					
					
					case 484831870:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "findPath", 484831870)) );
					}
					
					
					case 1987141354:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "set_mesh", 1987141354)) );
					}
					
					
					case 620486287:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "set_radius", 620486287)) );
					}
					
					
					case 561922075:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "get_radius", 561922075)) );
					}
					
					
					case 994869407:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "dispose", 994869407)) );
					}
					
					
					case 785065533:
					{
						return this.curFace;
					}
					
					
					case 2037325752:
					{
						return this.toFace;
					}
					
					
					case 562135847:
					{
						return this.fromFace;
					}
					
					
					case 1797678554:
					{
						return this.diameterSquared;
					}
					
					
					case 879259341:
					{
						return this.diameter;
					}
					
					
					case 281767669:
					{
						return this.radiusSquared;
					}
					
					
					case 17573237:
					{
						return this.iterEdge;
					}
					
					
					case 76261065:
					{
						return this.predecessor;
					}
					
					
					case 1164670134:
					{
						return this.scoreH;
					}
					
					
					case 1164670133:
					{
						return this.scoreG;
					}
					
					
					case 1164670132:
					{
						return this.scoreF;
					}
					
					
					case 86174631:
					{
						return this.entryY;
					}
					
					
					case 86174630:
					{
						return this.entryX;
					}
					
					
					case 1321437124:
					{
						return this.entryEdges;
					}
					
					
					case 1074666957:
					{
						return this.openedFaces;
					}
					
					
					case 402203024:
					{
						return this.sortedOpenedFaces;
					}
					
					
					case 266439658:
					{
						return this.closedFaces;
					}
					
					
					case 2070570444:
					{
						return this._mesh;
					}
					
					
					case 527294961:
					{
						return this._radius;
					}
					
					
					case 821481554:
					{
						return this.get_radius();
					}
					
					
					default:
					{
						return base.__hx_getField(field, hash, throwErrors, isCheck, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override double __hx_getField_f(string field, int hash, bool throwErrors, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 1797678554:
					{
						return this.diameterSquared;
					}
					
					
					case 879259341:
					{
						return this.diameter;
					}
					
					
					case 281767669:
					{
						return this.radiusSquared;
					}
					
					
					case 527294961:
					{
						return this._radius;
					}
					
					
					case 821481554:
					{
						return this.get_radius();
					}
					
					
					default:
					{
						return base.__hx_getField_f(field, hash, throwErrors, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_invokeField(string field, int hash, object[] dynargs) {
			unchecked {
				switch (hash) {
					case 794155990:
					{
						return this.isWalkableByRadius(((global::hxDaedalus.data.Edge) (dynargs[0]) ), ((global::hxDaedalus.data.Face) (dynargs[1]) ), ((global::hxDaedalus.data.Edge) (dynargs[2]) ));
					}
					
					
					case 824015442:
					{
						return this.sortingFaces(((global::hxDaedalus.data.Face) (dynargs[0]) ), ((global::hxDaedalus.data.Face) (dynargs[1]) ));
					}
					
					
					case 484831870:
					{
						this.findPath(((double) (global::haxe.lang.Runtime.toDouble(dynargs[0])) ), ((double) (global::haxe.lang.Runtime.toDouble(dynargs[1])) ), ((double) (global::haxe.lang.Runtime.toDouble(dynargs[2])) ), ((double) (global::haxe.lang.Runtime.toDouble(dynargs[3])) ), ((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (dynargs[4]) ))) ), ((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (dynargs[5]) ))) ));
						break;
					}
					
					
					case 1987141354:
					{
						return this.set_mesh(((global::hxDaedalus.data.Mesh) (dynargs[0]) ));
					}
					
					
					case 620486287:
					{
						return this.set_radius(((double) (global::haxe.lang.Runtime.toDouble(dynargs[0])) ));
					}
					
					
					case 561922075:
					{
						return this.get_radius();
					}
					
					
					case 994869407:
					{
						this.dispose();
						break;
					}
					
					
					default:
					{
						return base.__hx_invokeField(field, hash, dynargs);
					}
					
				}
				
				return null;
			}
		}
		
		
		public override void __hx_getFields(global::HxArray<string> baseArr) {
			baseArr.push("curFace");
			baseArr.push("toFace");
			baseArr.push("fromFace");
			baseArr.push("diameterSquared");
			baseArr.push("diameter");
			baseArr.push("radiusSquared");
			baseArr.push("iterEdge");
			baseArr.push("predecessor");
			baseArr.push("scoreH");
			baseArr.push("scoreG");
			baseArr.push("scoreF");
			baseArr.push("entryY");
			baseArr.push("entryX");
			baseArr.push("entryEdges");
			baseArr.push("openedFaces");
			baseArr.push("sortedOpenedFaces");
			baseArr.push("closedFaces");
			baseArr.push("_mesh");
			baseArr.push("mesh");
			baseArr.push("_radius");
			baseArr.push("radius");
			base.__hx_getFields(baseArr);
		}
		
		
	}
}


