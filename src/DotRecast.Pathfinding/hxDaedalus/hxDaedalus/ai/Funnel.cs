// Generated by Haxe 4.3.6

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace hxDaedalus.ai {
	public class Funnel : global::haxe.lang.HxObject {
		
		public Funnel(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public Funnel() {
			global::hxDaedalus.ai.Funnel.__hx_ctor_hxDaedalus_ai_Funnel(this);
		}
		
		
		protected static void __hx_ctor_hxDaedalus_ai_Funnel(global::hxDaedalus.ai.Funnel __hx_this) {
			unchecked {
				__hx_this._currPoolPointsIndex = 0;
				__hx_this._poolPointsSize = 3000;
				__hx_this._numSamplesCircle = 16;
				__hx_this._radiusSquared = 0;
				__hx_this._radius = 0;
				{
					__hx_this._poolPoints = new global::HxArray<object>();
					{
						int _g = 0;
						int _g1 = __hx_this._poolPointsSize;
						while (( _g < _g1 )) {
							int i = _g++;
							__hx_this._poolPoints.push(new global::hxDaedalus.data.math.Point2D(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>)));
						}
						
					}
					
				}
				
			}
		}
		
		
		
		
		public double _radius;
		
		public double _radiusSquared;
		
		public int _numSamplesCircle;
		
		public global::HxArray<object> _sampleCircle;
		
		public double _sampleCircleDistanceSquared;
		
		public virtual void dispose() {
			this._sampleCircle = null;
		}
		
		
		public int _poolPointsSize;
		
		public global::HxArray<object> _poolPoints;
		
		public int _currPoolPointsIndex;
		
		public global::hxDaedalus.data.math.Point2D __point;
		
		public virtual global::hxDaedalus.data.math.Point2D getPoint(global::haxe.lang.Null<double> x, global::haxe.lang.Null<double> y) {
			double y1 = ( ( ! (y.hasValue) ) ? (((double) (0) )) : ((y).@value) );
			double x1 = ( ( ! (x.hasValue) ) ? (((double) (0) )) : ((x).@value) );
			this.__point = ((global::hxDaedalus.data.math.Point2D) (this._poolPoints[this._currPoolPointsIndex]) );
			this.__point.setXY(x1, y1);
			this._currPoolPointsIndex++;
			if (( this._currPoolPointsIndex == this._poolPointsSize )) {
				this._poolPoints.push(new global::hxDaedalus.data.math.Point2D(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>)));
				this._poolPointsSize++;
			}
			
			return this.__point;
		}
		
		
		public virtual global::hxDaedalus.data.math.Point2D getCopyPoint(global::hxDaedalus.data.math.Point2D pointToCopy) {
			return this.getPoint(new global::haxe.lang.Null<double>(pointToCopy.x, true), new global::haxe.lang.Null<double>(pointToCopy.y, true));
		}
		
		
		public virtual double get_radius() {
			return this._radius;
		}
		
		
		public virtual double set_radius(double @value) {
			unchecked {
				this._radius = global::System.Math.Max(((double) (0) ), ((double) (@value) ));
				this._radiusSquared = ( this._radius * this._radius );
				this._sampleCircle = new global::HxArray<object>();
				if (( this.get_radius() == 0 )) {
					return ((double) (0) );
				}
				
				{
					int _g = 0;
					int _g1 = this._numSamplesCircle;
					while (( _g < _g1 )) {
						int i = _g++;
						this._sampleCircle.push(new global::hxDaedalus.data.math.Point2D(new global::haxe.lang.Null<double>(( this._radius * global::System.Math.Cos(((double) (( ( ( -2 * global::HxMath.PI ) * i ) / this._numSamplesCircle )) )) ), true), new global::haxe.lang.Null<double>(( this._radius * global::System.Math.Sin(((double) (( ( ( -2 * global::HxMath.PI ) * i ) / this._numSamplesCircle )) )) ), true)));
					}
					
				}
				
				this._sampleCircleDistanceSquared = ( ( (( ((global::hxDaedalus.data.math.Point2D) (this._sampleCircle[0]) ).x - ((global::hxDaedalus.data.math.Point2D) (this._sampleCircle[1]) ).x )) * (( ((global::hxDaedalus.data.math.Point2D) (this._sampleCircle[0]) ).x - ((global::hxDaedalus.data.math.Point2D) (this._sampleCircle[1]) ).x )) ) + ( (( ((global::hxDaedalus.data.math.Point2D) (this._sampleCircle[0]) ).y - ((global::hxDaedalus.data.math.Point2D) (this._sampleCircle[1]) ).y )) * (( ((global::hxDaedalus.data.math.Point2D) (this._sampleCircle[0]) ).y - ((global::hxDaedalus.data.math.Point2D) (this._sampleCircle[1]) ).y )) ) );
				return this._radius;
			}
		}
		
		
		public virtual void findPath(double fromX, double fromY, double toX, double toY, global::HxArray<object> listFaces, global::HxArray<object> listEdges, global::HxArray<double> resultPath) {
			unchecked {
				this._currPoolPointsIndex = 0;
				if (( this._radius > 0 )) {
					global::hxDaedalus.data.Face checkFace = ((global::hxDaedalus.data.Face) (listFaces[0]) );
					double distance = default(double);
					global::hxDaedalus.data.math.Point2D p1 = checkFace.get_edge().get_originVertex().get_pos();
					global::hxDaedalus.data.math.Point2D p2 = checkFace.get_edge().get_destinationVertex().get_pos();
					global::hxDaedalus.data.math.Point2D p3 = checkFace.get_edge().get_nextLeftEdge().get_destinationVertex().get_pos();
					double distanceSquared = ( ( (( p1.x - fromX )) * (( p1.x - fromX )) ) + ( (( p1.y - fromY )) * (( p1.y - fromY )) ) );
					if (( distanceSquared <= this._radiusSquared )) {
						distance = global::System.Math.Sqrt(((double) (distanceSquared) ));
						fromX = ( ( ( this._radius * 1.01 ) * (( (( fromX - p1.x )) / distance )) ) + p1.x );
						fromY = ( ( ( this._radius * 1.01 ) * (( (( fromY - p1.y )) / distance )) ) + p1.y );
					}
					else {
						distanceSquared = ( ( (( p2.x - fromX )) * (( p2.x - fromX )) ) + ( (( p2.y - fromY )) * (( p2.y - fromY )) ) );
						if (( distanceSquared <= this._radiusSquared )) {
							distance = global::System.Math.Sqrt(((double) (distanceSquared) ));
							fromX = ( ( ( this._radius * 1.01 ) * (( (( fromX - p2.x )) / distance )) ) + p2.x );
							fromY = ( ( ( this._radius * 1.01 ) * (( (( fromY - p2.y )) / distance )) ) + p2.y );
						}
						else {
							distanceSquared = ( ( (( p3.x - fromX )) * (( p3.x - fromX )) ) + ( (( p3.y - fromY )) * (( p3.y - fromY )) ) );
							if (( distanceSquared <= this._radiusSquared )) {
								distance = global::System.Math.Sqrt(((double) (distanceSquared) ));
								fromX = ( ( ( this._radius * 1.01 ) * (( (( fromX - p3.x )) / distance )) ) + p3.x );
								fromY = ( ( ( this._radius * 1.01 ) * (( (( fromY - p3.y )) / distance )) ) + p3.y );
							}
							
						}
						
					}
					
					checkFace = ((global::hxDaedalus.data.Face) (listFaces[( listFaces.length - 1 )]) );
					p1 = checkFace.get_edge().get_originVertex().get_pos();
					p2 = checkFace.get_edge().get_destinationVertex().get_pos();
					p3 = checkFace.get_edge().get_nextLeftEdge().get_destinationVertex().get_pos();
					distanceSquared = ( ( (( p1.x - toX )) * (( p1.x - toX )) ) + ( (( p1.y - toY )) * (( p1.y - toY )) ) );
					if (( distanceSquared <= this._radiusSquared )) {
						distance = global::System.Math.Sqrt(((double) (distanceSquared) ));
						toX = ( ( ( this._radius * 1.01 ) * (( (( toX - p1.x )) / distance )) ) + p1.x );
						toY = ( ( ( this._radius * 1.01 ) * (( (( toY - p1.y )) / distance )) ) + p1.y );
					}
					else {
						distanceSquared = ( ( (( p2.x - toX )) * (( p2.x - toX )) ) + ( (( p2.y - toY )) * (( p2.y - toY )) ) );
						if (( distanceSquared <= this._radiusSquared )) {
							distance = global::System.Math.Sqrt(((double) (distanceSquared) ));
							toX = ( ( ( this._radius * 1.01 ) * (( (( toX - p2.x )) / distance )) ) + p2.x );
							toY = ( ( ( this._radius * 1.01 ) * (( (( toY - p2.y )) / distance )) ) + p2.y );
						}
						else {
							distanceSquared = ( ( (( p3.x - toX )) * (( p3.x - toX )) ) + ( (( p3.y - toY )) * (( p3.y - toY )) ) );
							if (( distanceSquared <= this._radiusSquared )) {
								distance = global::System.Math.Sqrt(((double) (distanceSquared) ));
								toX = ( ( ( this._radius * 1.01 ) * (( (( toX - p3.x )) / distance )) ) + p3.x );
								toY = ( ( ( this._radius * 1.01 ) * (( (( toY - p3.y )) / distance )) ) + p3.y );
							}
							
						}
						
					}
					
				}
				
				global::hxDaedalus.data.math.Point2D startPoint = new global::hxDaedalus.data.math.Point2D(new global::haxe.lang.Null<double>(fromX, true), new global::haxe.lang.Null<double>(fromY, true));
				global::hxDaedalus.data.math.Point2D endPoint = new global::hxDaedalus.data.math.Point2D(new global::haxe.lang.Null<double>(toX, true), new global::haxe.lang.Null<double>(toY, true));
				if (( listFaces.length == 1 )) {
					resultPath.push(startPoint.x);
					resultPath.push(startPoint.y);
					resultPath.push(endPoint.x);
					resultPath.push(endPoint.y);
					return;
				}
				
				int i = default(int);
				int j = default(int);
				int k = default(int);
				global::hxDaedalus.data.Edge currEdge = null;
				global::hxDaedalus.data.Vertex currVertex = null;
				int direction = default(int);
				{
					global::hxDaedalus.data.math.Intersection _g = global::hxDaedalus.data.math.Geom2D.isInFace(fromX, fromY, ((global::hxDaedalus.data.Face) (listFaces[0]) ));
					if (( _g._hx_index == 1 )) {
						global::hxDaedalus.data.Edge edge = ( _g as global::hxDaedalus.data.math.Intersection_EEdge ).edge;
						if (( ((global::hxDaedalus.data.Edge) (listEdges[0]) ) == edge )) {
							global::hxDaedalus.data.Edge __temp_expr1 = ((global::hxDaedalus.data.Edge) ((listEdges.shift()).@value) );
							global::hxDaedalus.data.Face __temp_expr2 = ((global::hxDaedalus.data.Face) ((listFaces.shift()).@value) );
						}
						
					}
					
				}
				
				global::HxArray<object> funnelLeft = new global::HxArray<object>();
				global::HxArray<object> funnelRight = new global::HxArray<object>();
				funnelLeft.push(startPoint);
				funnelRight.push(startPoint);
				global::haxe.ds.ObjectMap<object, int> verticesDoneSide = new global::haxe.ds.ObjectMap<object, int>();
				global::HxArray<object> pointsList = new global::HxArray<object>();
				global::haxe.ds.ObjectMap<object, int> pointSides = new global::haxe.ds.ObjectMap<object, int>();
				global::haxe.ds.ObjectMap<object, object> pointSuccessor = new global::haxe.ds.ObjectMap<object, object>();
				pointSides.@set(startPoint, 0);
				currEdge = ((global::hxDaedalus.data.Edge) (listEdges[0]) );
				int relativPos = global::hxDaedalus.data.math.Geom2D.getRelativePosition2(fromX, fromY, currEdge);
				global::hxDaedalus.data.math.Point2D newPointA = this.getCopyPoint(currEdge.get_destinationVertex().get_pos());
				global::hxDaedalus.data.math.Point2D newPointB = this.getCopyPoint(currEdge.get_originVertex().get_pos());
				pointsList.push(newPointA);
				pointsList.push(newPointB);
				pointSuccessor.@set(startPoint, newPointA);
				pointSuccessor.@set(newPointA, newPointB);
				global::hxDaedalus.data.math.Point2D prevPoint = newPointB;
				if (( relativPos == 1 )) {
					pointSides.@set(newPointA, 1);
					pointSides.@set(newPointB, -1);
					verticesDoneSide.@set(currEdge.get_destinationVertex(), 1);
					verticesDoneSide.@set(currEdge.get_originVertex(), -1);
				}
				else if (( relativPos == -1 )) {
					pointSides.@set(newPointA, -1);
					pointSides.@set(newPointB, 1);
					verticesDoneSide.@set(currEdge.get_destinationVertex(), -1);
					verticesDoneSide.@set(currEdge.get_originVertex(), 1);
				}
				
				global::hxDaedalus.data.Vertex fromVertex = ((global::hxDaedalus.data.Edge) (listEdges[0]) ).get_originVertex();
				global::hxDaedalus.data.Vertex fromFromVertex = ((global::hxDaedalus.data.Edge) (listEdges[0]) ).get_destinationVertex();
				{
					int _g1 = 1;
					int _g2 = listEdges.length;
					while (( _g1 < _g2 )) {
						int i1 = _g1++;
						currEdge = ((global::hxDaedalus.data.Edge) (listEdges[i1]) );
						if (( currEdge.get_originVertex() == fromVertex )) {
							currVertex = currEdge.get_destinationVertex();
						}
						else if (( currEdge.get_destinationVertex() == fromVertex )) {
							currVertex = currEdge.get_originVertex();
						}
						else if (( currEdge.get_originVertex() == fromFromVertex )) {
							currVertex = currEdge.get_destinationVertex();
							fromVertex = fromFromVertex;
						}
						else if (( currEdge.get_destinationVertex() == fromFromVertex )) {
							currVertex = currEdge.get_originVertex();
							fromVertex = fromFromVertex;
						}
						
						newPointA = this.getCopyPoint(currVertex.get_pos());
						pointsList.push(newPointA);
						direction = ( - ((verticesDoneSide.@get(fromVertex)).@value) );
						pointSides.@set(newPointA, direction);
						pointSuccessor.@set(prevPoint, newPointA);
						verticesDoneSide.@set(currVertex, direction);
						prevPoint = newPointA;
						fromFromVertex = fromVertex;
						fromVertex = currVertex;
					}
					
				}
				
				pointSuccessor.@set(prevPoint, endPoint);
				pointSides.@set(endPoint, 0);
				global::HxArray<object> pathPoints = new global::HxArray<object>();
				global::haxe.ds.ObjectMap<object, int> pathSides = new global::haxe.ds.ObjectMap<object, int>();
				pathPoints.push(startPoint);
				pathSides.@set(startPoint, 0);
				global::hxDaedalus.data.math.Point2D currPos = null;
				{
					int _g3 = 0;
					int _g4 = pointsList.length;
					while (( _g3 < _g4 )) {
						int i2 = _g3++;
						currPos = ((global::hxDaedalus.data.math.Point2D) (pointsList[i2]) );
						if (global::haxe.lang.Runtime.eq((pointSides.@get(currPos)).toDynamic(), -1)) {
							j = ( funnelLeft.length - 2 );
							while (( j >= 0 )) {
								direction = global::hxDaedalus.data.math.Geom2D.getDirection(((global::hxDaedalus.data.math.Point2D) (funnelLeft[j]) ).x, ((global::hxDaedalus.data.math.Point2D) (funnelLeft[j]) ).y, ((global::hxDaedalus.data.math.Point2D) (funnelLeft[( j + 1 )]) ).x, ((global::hxDaedalus.data.math.Point2D) (funnelLeft[( j + 1 )]) ).y, currPos.x, currPos.y);
								if (( direction != -1 )) {
									global::hxDaedalus.data.math.Point2D __temp_expr5 = ((global::hxDaedalus.data.math.Point2D) ((funnelLeft.shift()).@value) );
									{
										int _g5 = 0;
										int _g6 = j;
										while (( _g5 < _g6 )) {
											int k1 = _g5++;
											pathPoints.push(((global::hxDaedalus.data.math.Point2D) (funnelLeft[0]) ));
											pathSides.@set(((global::hxDaedalus.data.math.Point2D) (funnelLeft[0]) ), 1);
											global::hxDaedalus.data.math.Point2D __temp_expr6 = ((global::hxDaedalus.data.math.Point2D) ((funnelLeft.shift()).@value) );
										}
										
									}
									
									pathPoints.push(((global::hxDaedalus.data.math.Point2D) (funnelLeft[0]) ));
									pathSides.@set(((global::hxDaedalus.data.math.Point2D) (funnelLeft[0]) ), 1);
									funnelRight.spliceVoid(0, funnelRight.length);
									funnelRight.push(((global::hxDaedalus.data.math.Point2D) (funnelLeft[0]) ));
									funnelRight.push(currPos);
									break;
								}
								
								 -- j;
							}
							
							funnelRight.push(currPos);
							j = ( funnelRight.length - 3 );
							while (( j >= 0 )) {
								direction = global::hxDaedalus.data.math.Geom2D.getDirection(((global::hxDaedalus.data.math.Point2D) (funnelRight[j]) ).x, ((global::hxDaedalus.data.math.Point2D) (funnelRight[j]) ).y, ((global::hxDaedalus.data.math.Point2D) (funnelRight[( j + 1 )]) ).x, ((global::hxDaedalus.data.math.Point2D) (funnelRight[( j + 1 )]) ).y, currPos.x, currPos.y);
								if (( direction == -1 )) {
									break;
								}
								else {
									funnelRight.spliceVoid(( j + 1 ), 1);
								}
								
								 -- j;
							}
							
						}
						else {
							j = ( funnelRight.length - 2 );
							while (( j >= 0 )) {
								direction = global::hxDaedalus.data.math.Geom2D.getDirection(((global::hxDaedalus.data.math.Point2D) (funnelRight[j]) ).x, ((global::hxDaedalus.data.math.Point2D) (funnelRight[j]) ).y, ((global::hxDaedalus.data.math.Point2D) (funnelRight[( j + 1 )]) ).x, ((global::hxDaedalus.data.math.Point2D) (funnelRight[( j + 1 )]) ).y, currPos.x, currPos.y);
								if (( direction != 1 )) {
									global::hxDaedalus.data.math.Point2D __temp_expr3 = ((global::hxDaedalus.data.math.Point2D) ((funnelRight.shift()).@value) );
									{
										int _g7 = 0;
										int _g8 = j;
										while (( _g7 < _g8 )) {
											int k2 = _g7++;
											pathPoints.push(((global::hxDaedalus.data.math.Point2D) (funnelRight[0]) ));
											pathSides.@set(((global::hxDaedalus.data.math.Point2D) (funnelRight[0]) ), -1);
											global::hxDaedalus.data.math.Point2D __temp_expr4 = ((global::hxDaedalus.data.math.Point2D) ((funnelRight.shift()).@value) );
										}
										
									}
									
									pathPoints.push(((global::hxDaedalus.data.math.Point2D) (funnelRight[0]) ));
									pathSides.@set(((global::hxDaedalus.data.math.Point2D) (funnelRight[0]) ), -1);
									funnelLeft.spliceVoid(0, funnelLeft.length);
									funnelLeft.push(((global::hxDaedalus.data.math.Point2D) (funnelRight[0]) ));
									funnelLeft.push(currPos);
									break;
								}
								
								 -- j;
							}
							
							funnelLeft.push(currPos);
							j = ( funnelLeft.length - 3 );
							while (( j >= 0 )) {
								direction = global::hxDaedalus.data.math.Geom2D.getDirection(((global::hxDaedalus.data.math.Point2D) (funnelLeft[j]) ).x, ((global::hxDaedalus.data.math.Point2D) (funnelLeft[j]) ).y, ((global::hxDaedalus.data.math.Point2D) (funnelLeft[( j + 1 )]) ).x, ((global::hxDaedalus.data.math.Point2D) (funnelLeft[( j + 1 )]) ).y, currPos.x, currPos.y);
								if (( direction == 1 )) {
									break;
								}
								else {
									funnelLeft.spliceVoid(( j + 1 ), 1);
								}
								
								 -- j;
							}
							
						}
						
					}
					
				}
				
				bool blocked = false;
				j = ( funnelRight.length - 2 );
				while (( j >= 0 )) {
					direction = global::hxDaedalus.data.math.Geom2D.getDirection(((global::hxDaedalus.data.math.Point2D) (funnelRight[j]) ).x, ((global::hxDaedalus.data.math.Point2D) (funnelRight[j]) ).y, ((global::hxDaedalus.data.math.Point2D) (funnelRight[( j + 1 )]) ).x, ((global::hxDaedalus.data.math.Point2D) (funnelRight[( j + 1 )]) ).y, toX, toY);
					if (( direction != 1 )) {
						global::hxDaedalus.data.math.Point2D __temp_expr7 = ((global::hxDaedalus.data.math.Point2D) ((funnelRight.shift()).@value) );
						{
							int _g9 = 0;
							int _g10 = ( j + 1 );
							while (( _g9 < _g10 )) {
								int k3 = _g9++;
								pathPoints.push(((global::hxDaedalus.data.math.Point2D) (funnelRight[0]) ));
								pathSides.@set(((global::hxDaedalus.data.math.Point2D) (funnelRight[0]) ), -1);
								global::hxDaedalus.data.math.Point2D __temp_expr8 = ((global::hxDaedalus.data.math.Point2D) ((funnelRight.shift()).@value) );
							}
							
						}
						
						pathPoints.push(endPoint);
						pathSides.@set(endPoint, 0);
						blocked = true;
						break;
					}
					
					 -- j;
				}
				
				if ( ! (blocked) ) {
					j = ( funnelLeft.length - 2 );
					while (( j >= 0 )) {
						direction = global::hxDaedalus.data.math.Geom2D.getDirection(((global::hxDaedalus.data.math.Point2D) (funnelLeft[j]) ).x, ((global::hxDaedalus.data.math.Point2D) (funnelLeft[j]) ).y, ((global::hxDaedalus.data.math.Point2D) (funnelLeft[( j + 1 )]) ).x, ((global::hxDaedalus.data.math.Point2D) (funnelLeft[( j + 1 )]) ).y, toX, toY);
						if (( direction != -1 )) {
							global::hxDaedalus.data.math.Point2D __temp_expr9 = ((global::hxDaedalus.data.math.Point2D) ((funnelLeft.shift()).@value) );
							{
								int _g11 = 0;
								int _g12 = ( j + 1 );
								while (( _g11 < _g12 )) {
									int k4 = _g11++;
									pathPoints.push(((global::hxDaedalus.data.math.Point2D) (funnelLeft[0]) ));
									pathSides.@set(((global::hxDaedalus.data.math.Point2D) (funnelLeft[0]) ), 1);
									global::hxDaedalus.data.math.Point2D __temp_expr10 = ((global::hxDaedalus.data.math.Point2D) ((funnelLeft.shift()).@value) );
								}
								
							}
							
							pathPoints.push(endPoint);
							pathSides.@set(endPoint, 0);
							blocked = true;
							break;
						}
						
						 -- j;
					}
					
				}
				
				if ( ! (blocked) ) {
					pathPoints.push(endPoint);
					pathSides.@set(endPoint, 0);
					blocked = true;
				}
				
				global::HxArray<object> adjustedPoints = new global::HxArray<object>();
				if (( this.get_radius() > 0 )) {
					global::HxArray<object> newPath = new global::HxArray<object>();
					if (( pathPoints.length == 2 )) {
						this.adjustWithTangents(((global::hxDaedalus.data.math.Point2D) (pathPoints[0]) ), false, ((global::hxDaedalus.data.math.Point2D) (pathPoints[1]) ), false, pointSides, pointSuccessor, newPath, adjustedPoints);
					}
					else if (( pathPoints.length > 2 )) {
						this.adjustWithTangents(((global::hxDaedalus.data.math.Point2D) (pathPoints[0]) ), false, ((global::hxDaedalus.data.math.Point2D) (pathPoints[1]) ), true, pointSides, pointSuccessor, newPath, adjustedPoints);
						if (( pathPoints.length > 3 )) {
							int _g13 = 1;
							int _g14 = ( ( pathPoints.length - 3 ) + 1 );
							while (( _g13 < _g14 )) {
								int i3 = _g13++;
								this.adjustWithTangents(((global::hxDaedalus.data.math.Point2D) (pathPoints[i3]) ), true, ((global::hxDaedalus.data.math.Point2D) (pathPoints[( i3 + 1 )]) ), true, pointSides, pointSuccessor, newPath, adjustedPoints);
							}
							
						}
						
						int pathLength = pathPoints.length;
						this.adjustWithTangents(((global::hxDaedalus.data.math.Point2D) (pathPoints[( pathLength - 2 )]) ), true, ((global::hxDaedalus.data.math.Point2D) (pathPoints[( pathLength - 1 )]) ), false, pointSides, pointSuccessor, newPath, adjustedPoints);
					}
					
					newPath.push(endPoint);
					this.checkAdjustedPath(newPath, adjustedPoints, pointSides);
					global::HxArray<object> smoothPoints = new global::HxArray<object>();
					i = ( newPath.length - 2 );
					while (( i >= 1 )) {
						this.smoothAngle(((global::hxDaedalus.data.math.Point2D) (adjustedPoints[( ( i * 2 ) - 1 )]) ), ((global::hxDaedalus.data.math.Point2D) (newPath[i]) ), ((global::hxDaedalus.data.math.Point2D) (adjustedPoints[( i * 2 )]) ), (pointSides.@get(((global::hxDaedalus.data.math.Point2D) (newPath[i]) ))).@value, smoothPoints);
						while (( smoothPoints.length != 0 )) {
							int temp = ( i * 2 );
							adjustedPoints.spliceVoid(temp, 0);
							adjustedPoints.insert(temp, ((global::hxDaedalus.data.math.Point2D) ((smoothPoints.pop()).@value) ));
						}
						
						 -- i;
					}
					
				}
				else {
					adjustedPoints = pathPoints;
				}
				
				{
					int _g15 = 0;
					int _g16 = adjustedPoints.length;
					while (( _g15 < _g16 )) {
						int i4 = _g15++;
						resultPath.push(((global::hxDaedalus.data.math.Point2D) (adjustedPoints[i4]) ).x);
						resultPath.push(((global::hxDaedalus.data.math.Point2D) (adjustedPoints[i4]) ).y);
					}
					
				}
				
			}
		}
		
		
		public virtual void adjustWithTangents(global::hxDaedalus.data.math.Point2D p1, bool applyRadiusToP1, global::hxDaedalus.data.math.Point2D p2, bool applyRadiusToP2, global::haxe.ds.ObjectMap<object, int> pointSides, global::haxe.ds.ObjectMap<object, object> pointSuccessor, global::HxArray<object> newPath, global::HxArray<object> adjustedPoints) {
			unchecked {
				global::HxArray<double> tangentsResult = new global::HxArray<double>();
				int side1 = (pointSides.@get(p1)).@value;
				int side2 = (pointSides.@get(p2)).@value;
				global::hxDaedalus.data.math.Point2D pTangent1 = null;
				global::hxDaedalus.data.math.Point2D pTangent2 = null;
				if ((  ! (applyRadiusToP1)  &&  ! (applyRadiusToP2)  )) {
					pTangent1 = p1;
					pTangent2 = p2;
				}
				else if ( ! (applyRadiusToP1) ) {
					if (global::hxDaedalus.data.math.Geom2D.tangentsPointToCircle(p1.x, p1.y, p2.x, p2.y, this._radius, tangentsResult)) {
						if (( side2 == 1 )) {
							pTangent1 = p1;
							pTangent2 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[2], true), new global::haxe.lang.Null<double>(tangentsResult[3], true));
						}
						else {
							pTangent1 = p1;
							pTangent2 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[0], true), new global::haxe.lang.Null<double>(tangentsResult[1], true));
						}
						
					}
					else {
						return;
					}
					
				}
				else if ( ! (applyRadiusToP2) ) {
					if (global::hxDaedalus.data.math.Geom2D.tangentsPointToCircle(p2.x, p2.y, p1.x, p1.y, this._radius, tangentsResult)) {
						if (( tangentsResult.length > 0 )) {
							if (( side1 == 1 )) {
								pTangent1 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[0], true), new global::haxe.lang.Null<double>(tangentsResult[1], true));
								pTangent2 = p2;
							}
							else {
								pTangent1 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[2], true), new global::haxe.lang.Null<double>(tangentsResult[3], true));
								pTangent2 = p2;
							}
							
						}
						
					}
					else {
						return;
					}
					
				}
				else if (( ( side1 == 1 ) && ( side2 == 1 ) )) {
					global::hxDaedalus.data.math.Geom2D.tangentsParalCircleToCircle(this._radius, p1.x, p1.y, p2.x, p2.y, tangentsResult);
					pTangent1 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[2], true), new global::haxe.lang.Null<double>(tangentsResult[3], true));
					pTangent2 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[4], true), new global::haxe.lang.Null<double>(tangentsResult[5], true));
				}
				else if (( ( side1 == -1 ) && ( side2 == -1 ) )) {
					global::hxDaedalus.data.math.Geom2D.tangentsParalCircleToCircle(this._radius, p1.x, p1.y, p2.x, p2.y, tangentsResult);
					pTangent1 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[0], true), new global::haxe.lang.Null<double>(tangentsResult[1], true));
					pTangent2 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[6], true), new global::haxe.lang.Null<double>(tangentsResult[7], true));
				}
				else if (( ( side1 == 1 ) && ( side2 == -1 ) )) {
					if (global::hxDaedalus.data.math.Geom2D.tangentsCrossCircleToCircle(this._radius, p1.x, p1.y, p2.x, p2.y, tangentsResult)) {
						pTangent1 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[2], true), new global::haxe.lang.Null<double>(tangentsResult[3], true));
						pTangent2 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[6], true), new global::haxe.lang.Null<double>(tangentsResult[7], true));
					}
					else {
						return;
					}
					
				}
				else if (global::hxDaedalus.data.math.Geom2D.tangentsCrossCircleToCircle(this._radius, p1.x, p1.y, p2.x, p2.y, tangentsResult)) {
					pTangent1 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[0], true), new global::haxe.lang.Null<double>(tangentsResult[1], true));
					pTangent2 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[4], true), new global::haxe.lang.Null<double>(tangentsResult[5], true));
				}
				else {
					return;
				}
				
				global::hxDaedalus.data.math.Point2D successor = ((global::hxDaedalus.data.math.Point2D) ((pointSuccessor.@get(p1)).@value) );
				double distance = default(double);
				while (( successor != p2 )) {
					distance = global::hxDaedalus.data.math.Geom2D.distanceSquaredPointToSegment(successor.x, successor.y, pTangent1.x, pTangent1.y, pTangent2.x, pTangent2.y);
					if (( distance < this._radiusSquared )) {
						this.adjustWithTangents(p1, applyRadiusToP1, successor, true, pointSides, pointSuccessor, newPath, adjustedPoints);
						this.adjustWithTangents(successor, true, p2, applyRadiusToP2, pointSides, pointSuccessor, newPath, adjustedPoints);
						return;
					}
					else {
						successor = ((global::hxDaedalus.data.math.Point2D) ((pointSuccessor.@get(successor)).@value) );
					}
					
				}
				
				adjustedPoints.push(pTangent1);
				adjustedPoints.push(pTangent2);
				newPath.push(p1);
			}
		}
		
		
		public virtual void checkAdjustedPath(global::HxArray<object> newPath, global::HxArray<object> adjustedPoints, global::haxe.ds.ObjectMap<object, int> pointSides) {
			unchecked {
				bool needCheck = true;
				global::hxDaedalus.data.math.Point2D point0 = null;
				int point0Side = default(int);
				global::hxDaedalus.data.math.Point2D point1 = null;
				int point1Side = default(int);
				global::hxDaedalus.data.math.Point2D point2 = null;
				int point2Side = default(int);
				global::hxDaedalus.data.math.Point2D pt1 = null;
				global::hxDaedalus.data.math.Point2D pt2 = null;
				global::hxDaedalus.data.math.Point2D pt3 = null;
				double dot = default(double);
				global::HxArray<double> tangentsResult = new global::HxArray<double>();
				global::hxDaedalus.data.math.Point2D pTangent1 = null;
				global::hxDaedalus.data.math.Point2D pTangent2 = null;
				while (needCheck) {
					needCheck = false;
					int i = 2;
					while (( i < newPath.length )) {
						point2 = ((global::hxDaedalus.data.math.Point2D) (newPath[i]) );
						point2Side = (pointSides.@get(point2)).@value;
						point1 = ((global::hxDaedalus.data.math.Point2D) (newPath[( i - 1 )]) );
						point1Side = (pointSides.@get(point1)).@value;
						point0 = ((global::hxDaedalus.data.math.Point2D) (newPath[( i - 2 )]) );
						point0Side = (pointSides.@get(point0)).@value;
						if (( point1Side == point2Side )) {
							pt1 = ((global::hxDaedalus.data.math.Point2D) (adjustedPoints[( (( i - 2 )) * 2 )]) );
							pt2 = ((global::hxDaedalus.data.math.Point2D) (adjustedPoints[( ( (( i - 1 )) * 2 ) - 1 )]) );
							pt3 = ((global::hxDaedalus.data.math.Point2D) (adjustedPoints[( (( i - 1 )) * 2 )]) );
							dot = ( ( (( pt1.x - pt2.x )) * (( pt3.x - pt2.x )) ) + ( (( pt1.y - pt2.y )) * (( pt3.y - pt2.y )) ) );
							if (( dot > 0 )) {
								if (( i == 2 )) {
									global::hxDaedalus.data.math.Geom2D.tangentsPointToCircle(point0.x, point0.y, point2.x, point2.y, this._radius, tangentsResult);
									if (( point2Side == 1 )) {
										pTangent1 = point0;
										pTangent2 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[2], true), new global::haxe.lang.Null<double>(tangentsResult[3], true));
									}
									else {
										pTangent1 = point0;
										pTangent2 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[0], true), new global::haxe.lang.Null<double>(tangentsResult[1], true));
									}
									
								}
								else if (( i == ( newPath.length - 1 ) )) {
									global::hxDaedalus.data.math.Geom2D.tangentsPointToCircle(point2.x, point2.y, point0.x, point0.y, this._radius, tangentsResult);
									if (( point0Side == 1 )) {
										pTangent1 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[0], true), new global::haxe.lang.Null<double>(tangentsResult[1], true));
										pTangent2 = point2;
									}
									else {
										pTangent1 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[2], true), new global::haxe.lang.Null<double>(tangentsResult[3], true));
										pTangent2 = point2;
									}
									
								}
								else if (( ( point0Side == 1 ) && ( point2Side == -1 ) )) {
									global::hxDaedalus.data.math.Geom2D.tangentsCrossCircleToCircle(this._radius, point0.x, point0.y, point2.x, point2.y, tangentsResult);
									pTangent1 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[2], true), new global::haxe.lang.Null<double>(tangentsResult[3], true));
									pTangent2 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[6], true), new global::haxe.lang.Null<double>(tangentsResult[7], true));
								}
								else if (( ( point0Side == -1 ) && ( point2Side == 1 ) )) {
									global::hxDaedalus.data.math.Geom2D.tangentsCrossCircleToCircle(this._radius, point0.x, point0.y, point2.x, point2.y, tangentsResult);
									pTangent1 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[0], true), new global::haxe.lang.Null<double>(tangentsResult[1], true));
									pTangent2 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[4], true), new global::haxe.lang.Null<double>(tangentsResult[5], true));
								}
								else if (( ( point0Side == 1 ) && ( point2Side == 1 ) )) {
									global::hxDaedalus.data.math.Geom2D.tangentsParalCircleToCircle(this._radius, point0.x, point0.y, point2.x, point2.y, tangentsResult);
									pTangent1 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[2], true), new global::haxe.lang.Null<double>(tangentsResult[3], true));
									pTangent2 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[4], true), new global::haxe.lang.Null<double>(tangentsResult[5], true));
								}
								else if (( ( point0Side == -1 ) && ( point2Side == -1 ) )) {
									global::hxDaedalus.data.math.Geom2D.tangentsParalCircleToCircle(this._radius, point0.x, point0.y, point2.x, point2.y, tangentsResult);
									pTangent1 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[0], true), new global::haxe.lang.Null<double>(tangentsResult[1], true));
									pTangent2 = this.getPoint(new global::haxe.lang.Null<double>(tangentsResult[6], true), new global::haxe.lang.Null<double>(tangentsResult[7], true));
								}
								
								int temp = ( (( i - 2 )) * 2 );
								adjustedPoints.spliceVoid(temp, 1);
								adjustedPoints.insert(temp, pTangent1);
								temp = ( ( i * 2 ) - 1 );
								adjustedPoints.spliceVoid(temp, 1);
								adjustedPoints.insert(temp, pTangent2);
								newPath.spliceVoid(( i - 1 ), 1);
								adjustedPoints.spliceVoid(( ( (( i - 1 )) * 2 ) - 1 ), 2);
								tangentsResult.spliceVoid(0, tangentsResult.length);
								 -- i;
							}
							
						}
						
						 ++ i;
					}
					
				}
				
			}
		}
		
		
		public virtual void smoothAngle(global::hxDaedalus.data.math.Point2D prevPoint, global::hxDaedalus.data.math.Point2D pointToSmooth, global::hxDaedalus.data.math.Point2D nextPoint, int side, global::HxArray<object> encirclePoints) {
			unchecked {
				int angleType = global::hxDaedalus.data.math.Geom2D.getDirection(prevPoint.x, prevPoint.y, pointToSmooth.x, pointToSmooth.y, nextPoint.x, nextPoint.y);
				double distanceSquared = ( ( (( prevPoint.x - nextPoint.x )) * (( prevPoint.x - nextPoint.x )) ) + ( (( prevPoint.y - nextPoint.y )) * (( prevPoint.y - nextPoint.y )) ) );
				if (( distanceSquared <= this._sampleCircleDistanceSquared )) {
					return;
				}
				
				int index = 0;
				int side1 = default(int);
				int side2 = default(int);
				bool pointInArea = default(bool);
				double xToCheck = default(double);
				double yToCheck = default(double);
				{
					int _g = 0;
					int _g1 = this._numSamplesCircle;
					while (( _g < _g1 )) {
						int i = _g++;
						pointInArea = false;
						xToCheck = ( pointToSmooth.x + ((global::hxDaedalus.data.math.Point2D) (this._sampleCircle[i]) ).x );
						yToCheck = ( pointToSmooth.y + ((global::hxDaedalus.data.math.Point2D) (this._sampleCircle[i]) ).y );
						side1 = global::hxDaedalus.data.math.Geom2D.getDirection(prevPoint.x, prevPoint.y, pointToSmooth.x, pointToSmooth.y, xToCheck, yToCheck);
						side2 = global::hxDaedalus.data.math.Geom2D.getDirection(pointToSmooth.x, pointToSmooth.y, nextPoint.x, nextPoint.y, xToCheck, yToCheck);
						if (( side == 1 )) {
							if (( angleType == -1 )) {
								if (( ( side1 == -1 ) && ( side2 == -1 ) )) {
									pointInArea = true;
								}
								
							}
							else if (( ( side1 == -1 ) || ( side2 == -1 ) )) {
								pointInArea = true;
							}
							
						}
						else if (( angleType == 1 )) {
							if (( ( side1 == 1 ) && ( side2 == 1 ) )) {
								pointInArea = true;
							}
							
						}
						else if (( ( side1 == 1 ) || ( side2 == 1 ) )) {
							pointInArea = true;
						}
						
						if (pointInArea) {
							encirclePoints.spliceVoid(index, 0);
							encirclePoints.insert(index, new global::hxDaedalus.data.math.Point2D(new global::haxe.lang.Null<double>(xToCheck, true), new global::haxe.lang.Null<double>(yToCheck, true)));
							 ++ index;
						}
						else {
							index = 0;
						}
						
					}
					
				}
				
				if (( side == -1 )) {
					encirclePoints.reverse();
				}
				
			}
		}
		
		
		public override double __hx_setField_f(string field, int hash, double @value, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 882809506:
					{
						this._currPoolPointsIndex = ((int) (@value) );
						return @value;
					}
					
					
					case 1157899551:
					{
						this._poolPointsSize = ((int) (@value) );
						return @value;
					}
					
					
					case 1949305273:
					{
						this._sampleCircleDistanceSquared = ((double) (@value) );
						return @value;
					}
					
					
					case 2008548402:
					{
						this._numSamplesCircle = ((int) (@value) );
						return @value;
					}
					
					
					case 1327324982:
					{
						this._radiusSquared = ((double) (@value) );
						return @value;
					}
					
					
					case 527294961:
					{
						this._radius = ((double) (@value) );
						return @value;
					}
					
					
					case 821481554:
					{
						this.set_radius(@value);
						return @value;
					}
					
					
					default:
					{
						return base.__hx_setField_f(field, hash, @value, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_setField(string field, int hash, object @value, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 820907312:
					{
						this.__point = ((global::hxDaedalus.data.math.Point2D) (@value) );
						return @value;
					}
					
					
					case 882809506:
					{
						this._currPoolPointsIndex = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 1836769598:
					{
						this._poolPoints = ((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (@value) ))) );
						return @value;
					}
					
					
					case 1157899551:
					{
						this._poolPointsSize = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 1949305273:
					{
						this._sampleCircleDistanceSquared = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					case 2095600825:
					{
						this._sampleCircle = ((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (@value) ))) );
						return @value;
					}
					
					
					case 2008548402:
					{
						this._numSamplesCircle = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 1327324982:
					{
						this._radiusSquared = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					case 527294961:
					{
						this._radius = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					case 821481554:
					{
						this.set_radius(((double) (global::haxe.lang.Runtime.toDouble(@value)) ));
						return @value;
					}
					
					
					default:
					{
						return base.__hx_setField(field, hash, @value, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_getField(string field, int hash, bool throwErrors, bool isCheck, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 705840325:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "smoothAngle", 705840325)) );
					}
					
					
					case 200251483:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "checkAdjustedPath", 200251483)) );
					}
					
					
					case 1493724003:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "adjustWithTangents", 1493724003)) );
					}
					
					
					case 484831870:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "findPath", 484831870)) );
					}
					
					
					case 620486287:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "set_radius", 620486287)) );
					}
					
					
					case 561922075:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "get_radius", 561922075)) );
					}
					
					
					case 1541502181:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "getCopyPoint", 1541502181)) );
					}
					
					
					case 644269018:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "getPoint", 644269018)) );
					}
					
					
					case 820907312:
					{
						return this.__point;
					}
					
					
					case 882809506:
					{
						return this._currPoolPointsIndex;
					}
					
					
					case 1836769598:
					{
						return this._poolPoints;
					}
					
					
					case 1157899551:
					{
						return this._poolPointsSize;
					}
					
					
					case 994869407:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "dispose", 994869407)) );
					}
					
					
					case 1949305273:
					{
						return this._sampleCircleDistanceSquared;
					}
					
					
					case 2095600825:
					{
						return this._sampleCircle;
					}
					
					
					case 2008548402:
					{
						return this._numSamplesCircle;
					}
					
					
					case 1327324982:
					{
						return this._radiusSquared;
					}
					
					
					case 527294961:
					{
						return this._radius;
					}
					
					
					case 821481554:
					{
						return this.get_radius();
					}
					
					
					default:
					{
						return base.__hx_getField(field, hash, throwErrors, isCheck, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override double __hx_getField_f(string field, int hash, bool throwErrors, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 882809506:
					{
						return ((double) (this._currPoolPointsIndex) );
					}
					
					
					case 1157899551:
					{
						return ((double) (this._poolPointsSize) );
					}
					
					
					case 1949305273:
					{
						return this._sampleCircleDistanceSquared;
					}
					
					
					case 2008548402:
					{
						return ((double) (this._numSamplesCircle) );
					}
					
					
					case 1327324982:
					{
						return this._radiusSquared;
					}
					
					
					case 527294961:
					{
						return this._radius;
					}
					
					
					case 821481554:
					{
						return this.get_radius();
					}
					
					
					default:
					{
						return base.__hx_getField_f(field, hash, throwErrors, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_invokeField(string field, int hash, object[] dynargs) {
			unchecked {
				switch (hash) {
					case 705840325:
					{
						this.smoothAngle(((global::hxDaedalus.data.math.Point2D) (dynargs[0]) ), ((global::hxDaedalus.data.math.Point2D) (dynargs[1]) ), ((global::hxDaedalus.data.math.Point2D) (dynargs[2]) ), ((int) (global::haxe.lang.Runtime.toInt(dynargs[3])) ), ((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (dynargs[4]) ))) ));
						break;
					}
					
					
					case 200251483:
					{
						this.checkAdjustedPath(((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (dynargs[0]) ))) ), ((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (dynargs[1]) ))) ), ((global::haxe.ds.ObjectMap<object, int>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, int>(((global::haxe.ds.ObjectMap) (dynargs[2]) ))) ));
						break;
					}
					
					
					case 1493724003:
					{
						this.adjustWithTangents(((global::hxDaedalus.data.math.Point2D) (dynargs[0]) ), global::haxe.lang.Runtime.toBool(dynargs[1]), ((global::hxDaedalus.data.math.Point2D) (dynargs[2]) ), global::haxe.lang.Runtime.toBool(dynargs[3]), ((global::haxe.ds.ObjectMap<object, int>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, int>(((global::haxe.ds.ObjectMap) (dynargs[4]) ))) ), ((global::haxe.ds.ObjectMap<object, object>) (global::haxe.ds.ObjectMap<object, object>.__hx_cast<object, object>(((global::haxe.ds.ObjectMap) (dynargs[5]) ))) ), ((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (dynargs[6]) ))) ), ((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (dynargs[7]) ))) ));
						break;
					}
					
					
					case 484831870:
					{
						this.findPath(((double) (global::haxe.lang.Runtime.toDouble(dynargs[0])) ), ((double) (global::haxe.lang.Runtime.toDouble(dynargs[1])) ), ((double) (global::haxe.lang.Runtime.toDouble(dynargs[2])) ), ((double) (global::haxe.lang.Runtime.toDouble(dynargs[3])) ), ((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (dynargs[4]) ))) ), ((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (dynargs[5]) ))) ), ((global::HxArray<double>) (global::HxArray<object>.__hx_cast<double>(((global::HxArray) (dynargs[6]) ))) ));
						break;
					}
					
					
					case 620486287:
					{
						return this.set_radius(((double) (global::haxe.lang.Runtime.toDouble(dynargs[0])) ));
					}
					
					
					case 561922075:
					{
						return this.get_radius();
					}
					
					
					case 1541502181:
					{
						return this.getCopyPoint(((global::hxDaedalus.data.math.Point2D) (dynargs[0]) ));
					}
					
					
					case 644269018:
					{
						return this.getPoint(global::haxe.lang.Null<object>.ofDynamic<double>(( (( dynargs.Length > 0 )) ? (dynargs[0]) : (null) )), global::haxe.lang.Null<object>.ofDynamic<double>(( (( dynargs.Length > 1 )) ? (dynargs[1]) : (null) )));
					}
					
					
					case 994869407:
					{
						this.dispose();
						break;
					}
					
					
					default:
					{
						return base.__hx_invokeField(field, hash, dynargs);
					}
					
				}
				
				return null;
			}
		}
		
		
		public override void __hx_getFields(global::HxArray<string> baseArr) {
			baseArr.push("__point");
			baseArr.push("_currPoolPointsIndex");
			baseArr.push("_poolPoints");
			baseArr.push("_poolPointsSize");
			baseArr.push("_sampleCircleDistanceSquared");
			baseArr.push("_sampleCircle");
			baseArr.push("_numSamplesCircle");
			baseArr.push("_radiusSquared");
			baseArr.push("_radius");
			baseArr.push("radius");
			base.__hx_getFields(baseArr);
		}
		
		
	}
}


