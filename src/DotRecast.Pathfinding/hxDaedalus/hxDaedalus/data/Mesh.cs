// Generated by Haxe 4.3.6

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace hxDaedalus.data {
	public class Mesh : global::haxe.lang.HxObject {
		
		static Mesh() {
			global::hxDaedalus.data.Mesh.INC = 0;
		}
		
		
		public Mesh(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public Mesh(double width, double height) {
			global::hxDaedalus.data.Mesh.__hx_ctor_hxDaedalus_data_Mesh(this, width, height);
		}
		
		
		protected static void __hx_ctor_hxDaedalus_data_Mesh(global::hxDaedalus.data.Mesh __hx_this, double width, double height) {
			__hx_this.__objectsUpdateInProgress = false;
			__hx_this.__edgesToCheck = null;
			__hx_this.__centerVertex = null;
			__hx_this._objects = null;
			__hx_this._constraintShapes = null;
			__hx_this._faces = null;
			__hx_this._edges = null;
			__hx_this._vertices = null;
			__hx_this._clipping = false;
			__hx_this._height = 0;
			__hx_this._width = 0;
			{
				__hx_this._id = global::hxDaedalus.data.Mesh.INC;
				global::hxDaedalus.data.Mesh.INC++;
				__hx_this._width = width;
				__hx_this._height = height;
				__hx_this._clipping = true;
				__hx_this._vertices = new global::HxArray<object>();
				__hx_this._edges = new global::HxArray<object>();
				__hx_this._faces = new global::HxArray<object>();
				__hx_this._constraintShapes = new global::HxArray<object>();
				__hx_this._objects = new global::HxArray<object>();
				__hx_this.__edgesToCheck = new global::HxArray<object>();
			}
			
		}
		
		
		public static int INC;
		
		
		
		
		
		
		
		
		
		
		
		public int _id;
		
		public double _width;
		
		public double _height;
		
		public bool _clipping;
		
		public global::HxArray<object> _vertices;
		
		public global::HxArray<object> _edges;
		
		public global::HxArray<object> _faces;
		
		public global::HxArray<object> _constraintShapes;
		
		public global::HxArray<object> _objects;
		
		public global::hxDaedalus.data.Vertex __centerVertex;
		
		public global::HxArray<object> __edgesToCheck;
		
		public virtual double get_height() {
			return this._height;
		}
		
		
		public virtual double get_width() {
			return this._width;
		}
		
		
		public virtual bool get_clipping() {
			return this._clipping;
		}
		
		
		public virtual bool set_clipping(bool @value) {
			this._clipping = @value;
			return @value;
		}
		
		
		public virtual int get_id() {
			return this._id;
		}
		
		
		public virtual void dispose() {
			while (( this._vertices.length > 0 )) {
				((global::hxDaedalus.data.Vertex) ((this._vertices.pop()).@value) ).dispose();
			}
			
			this._vertices = null;
			while (( this._edges.length > 0 )) {
				((global::hxDaedalus.data.Edge) ((this._edges.pop()).@value) ).dispose();
			}
			
			this._edges = null;
			while (( this._faces.length > 0 )) {
				((global::hxDaedalus.data.Face) ((this._faces.pop()).@value) ).dispose();
			}
			
			this._faces = null;
			while (( this._constraintShapes.length > 0 )) {
				((global::hxDaedalus.data.ConstraintShape) ((this._constraintShapes.pop()).@value) ).dispose();
			}
			
			this._constraintShapes = null;
			while (( this._objects.length > 0 )) {
				((global::hxDaedalus.data.Object) ((this._objects.pop()).@value) ).dispose();
			}
			
			this._objects = null;
			this.__edgesToCheck = null;
			this.__centerVertex = null;
		}
		
		
		public virtual global::HxArray<object> get___constraintShapes() {
			return this._constraintShapes;
		}
		
		
		public virtual void buildFromRecord(string rec) {
			unchecked {
				global::HxArray<string> positions = global::haxe.lang.StringExt.split(rec, ";");
				int i = 0;
				while (( i < positions.length )) {
					this.insertConstraintSegment(global::HxStd.parseFloat(positions[i]), global::HxStd.parseFloat(positions[( i + 1 )]), global::HxStd.parseFloat(positions[( i + 2 )]), global::HxStd.parseFloat(positions[( i + 3 )]));
					i += 4;
				}
				
			}
		}
		
		
		public virtual void insertObject(global::hxDaedalus.data.Object @object) {
			unchecked {
				if (( @object.get_constraintShape() != null )) {
					this.deleteObject(@object);
				}
				
				global::hxDaedalus.data.ConstraintShape shape = new global::hxDaedalus.data.ConstraintShape();
				global::hxDaedalus.data.ConstraintSegment segment = null;
				global::HxArray<double> coordinates = @object.get_coordinates();
				global::hxDaedalus.data.math.Matrix2D m = @object.get_matrix();
				@object.updateMatrixFromValues();
				double x1 = default(double);
				double y1 = default(double);
				double x2 = default(double);
				double y2 = default(double);
				double transfx1 = default(double);
				double transfy1 = default(double);
				double transfx2 = default(double);
				double transfy2 = default(double);
				int i = 0;
				while (( i < coordinates.length )) {
					x1 = coordinates[i];
					y1 = coordinates[( i + 1 )];
					x2 = coordinates[( i + 2 )];
					y2 = coordinates[( i + 3 )];
					transfx1 = m.transformX(x1, y1);
					transfy1 = m.transformY(x1, y1);
					transfx2 = m.transformX(x2, y2);
					transfy2 = m.transformY(x2, y2);
					segment = this.insertConstraintSegment(transfx1, transfy1, transfx2, transfy2);
					if (( segment != null )) {
						segment.fromShape = shape;
						shape.segments.push(segment);
					}
					
					i += 4;
				}
				
				this._constraintShapes.push(shape);
				@object.set_constraintShape(shape);
				if ( ! (this.__objectsUpdateInProgress) ) {
					this._objects.push(@object);
				}
				
			}
		}
		
		
		public virtual void deleteObject(global::hxDaedalus.data.Object @object) {
			unchecked {
				if (( @object.get_constraintShape() == null )) {
					return;
				}
				
				this.deleteConstraintShape(@object.get_constraintShape());
				@object.set_constraintShape(null);
				if ( ! (this.__objectsUpdateInProgress) ) {
					int index = this._objects.indexOf(@object, default(global::haxe.lang.Null<int>));
					this._objects.spliceVoid(index, 1);
				}
				
			}
		}
		
		
		public bool __objectsUpdateInProgress;
		
		public virtual void updateObjects() {
			this.__objectsUpdateInProgress = true;
			{
				int _g = 0;
				int _g1 = this._objects.length;
				while (( _g < _g1 )) {
					int i = _g++;
					if (((global::hxDaedalus.data.Object) (this._objects[i]) ).get_hasChanged()) {
						this.deleteObject(((global::hxDaedalus.data.Object) (this._objects[i]) ));
						this.insertObject(((global::hxDaedalus.data.Object) (this._objects[i]) ));
						((global::hxDaedalus.data.Object) (this._objects[i]) ).set_hasChanged(false);
					}
					
				}
				
			}
			
			this.__objectsUpdateInProgress = false;
		}
		
		
		public virtual global::hxDaedalus.data.ConstraintShape insertConstraintShape(global::HxArray<double> coordinates) {
			unchecked {
				global::hxDaedalus.data.ConstraintShape shape = new global::hxDaedalus.data.ConstraintShape();
				global::hxDaedalus.data.ConstraintSegment segment = null;
				int i = 0;
				while (( i < coordinates.length )) {
					segment = this.insertConstraintSegment(coordinates[i], coordinates[( i + 1 )], coordinates[( i + 2 )], coordinates[( i + 3 )]);
					if (( segment != null )) {
						segment.fromShape = shape;
						shape.segments.push(segment);
					}
					
					i += 4;
				}
				
				this._constraintShapes.push(shape);
				return shape;
			}
		}
		
		
		public virtual void deleteConstraintShape(global::hxDaedalus.data.ConstraintShape shape) {
			unchecked {
				{
					int _g = 0;
					int _g1 = shape.segments.length;
					while (( _g < _g1 )) {
						int i = _g++;
						this.deleteConstraintSegment(((global::hxDaedalus.data.ConstraintSegment) (shape.segments[i]) ));
					}
					
				}
				
				shape.dispose();
				this._constraintShapes.spliceVoid(this._constraintShapes.indexOf(shape, default(global::haxe.lang.Null<int>)), 1);
			}
		}
		
		
		public virtual global::hxDaedalus.data.ConstraintSegment insertConstraintSegment(double x1, double y1, double x2, double y2) {
			unchecked {
				int p1pos = this.findPositionFromBounds(x1, y1);
				int p2pos = this.findPositionFromBounds(x2, y2);
				double newX1 = x1;
				double newY1 = y1;
				double newX2 = x2;
				double newY2 = y2;
				if (( this._clipping && (( ( p1pos != 0 ) || ( p2pos != 0 ) )) )) {
					global::hxDaedalus.data.math.Point2D intersectPoint = new global::hxDaedalus.data.math.Point2D(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					if (( ( p1pos != 0 ) && ( p2pos != 0 ) )) {
						if (( ( ( ( ( x1 <= 0 ) && ( x2 <= 0 ) ) || ( ( x1 >= this._width ) && ( x2 >= this._width ) ) ) || ( ( y1 <= 0 ) && ( y2 <= 0 ) ) ) || ( ( y1 >= this._height ) && ( y2 >= this._height ) ) )) {
							return null;
						}
						
						if (( ( ( p1pos == 8 ) && ( p2pos == 4 ) ) || ( ( p1pos == 4 ) && ( p2pos == 8 ) ) )) {
							global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, ((double) (0) ), ((double) (0) ), ((double) (0) ), this._height, intersectPoint, null, default(global::haxe.lang.Null<bool>));
							newX1 = intersectPoint.x;
							newY1 = intersectPoint.y;
							global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, this._width, ((double) (0) ), this._width, this._height, intersectPoint, null, default(global::haxe.lang.Null<bool>));
							newX2 = intersectPoint.x;
							newY2 = intersectPoint.y;
						}
						else if (( ( ( p1pos == 2 ) && ( p2pos == 6 ) ) || ( ( p1pos == 6 ) && ( p2pos == 2 ) ) )) {
							global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, ((double) (0) ), ((double) (0) ), this._width, ((double) (0) ), intersectPoint, null, default(global::haxe.lang.Null<bool>));
							newX1 = intersectPoint.x;
							newY1 = intersectPoint.y;
							global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, ((double) (0) ), this._height, this._width, this._height, intersectPoint, null, default(global::haxe.lang.Null<bool>));
							newX2 = intersectPoint.x;
							newY2 = intersectPoint.y;
						}
						else if (( ( ( p1pos == 2 ) && ( p2pos == 8 ) ) || ( ( p1pos == 8 ) && ( p2pos == 2 ) ) )) {
							if (global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, ((double) (0) ), ((double) (0) ), this._width, ((double) (0) ), intersectPoint, null, default(global::haxe.lang.Null<bool>))) {
								newX1 = intersectPoint.x;
								newY1 = intersectPoint.y;
								global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, ((double) (0) ), ((double) (0) ), ((double) (0) ), this._height, intersectPoint, null, default(global::haxe.lang.Null<bool>));
								newX2 = intersectPoint.x;
								newY2 = intersectPoint.y;
							}
							else {
								return null;
							}
							
						}
						else if (( ( ( p1pos == 2 ) && ( p2pos == 4 ) ) || ( ( p1pos == 4 ) && ( p2pos == 2 ) ) )) {
							if (global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, ((double) (0) ), ((double) (0) ), this._width, ((double) (0) ), intersectPoint, null, default(global::haxe.lang.Null<bool>))) {
								newX1 = intersectPoint.x;
								newY1 = intersectPoint.y;
								global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, this._width, ((double) (0) ), this._width, this._height, intersectPoint, null, default(global::haxe.lang.Null<bool>));
								newX2 = intersectPoint.x;
								newY2 = intersectPoint.y;
							}
							else {
								return null;
							}
							
						}
						else if (( ( ( p1pos == 6 ) && ( p2pos == 4 ) ) || ( ( p1pos == 4 ) && ( p2pos == 6 ) ) )) {
							if (global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, ((double) (0) ), this._height, this._width, this._height, intersectPoint, null, default(global::haxe.lang.Null<bool>))) {
								newX1 = intersectPoint.x;
								newY1 = intersectPoint.y;
								global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, this._width, ((double) (0) ), this._width, this._height, intersectPoint, null, default(global::haxe.lang.Null<bool>));
								newX2 = intersectPoint.x;
								newY2 = intersectPoint.y;
							}
							else {
								return null;
							}
							
						}
						else if (( ( ( p1pos == 8 ) && ( p2pos == 6 ) ) || ( ( p1pos == 6 ) && ( p2pos == 8 ) ) )) {
							if (global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, ((double) (0) ), this._height, this._width, this._height, intersectPoint, null, default(global::haxe.lang.Null<bool>))) {
								newX1 = intersectPoint.x;
								newY1 = intersectPoint.y;
								global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, ((double) (0) ), ((double) (0) ), ((double) (0) ), this._height, intersectPoint, null, default(global::haxe.lang.Null<bool>));
								newX2 = intersectPoint.x;
								newY2 = intersectPoint.y;
							}
							else {
								return null;
							}
							
						}
						else {
							bool firstDone = false;
							bool secondDone = false;
							if (global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, ((double) (0) ), ((double) (0) ), this._width, ((double) (0) ), intersectPoint, null, default(global::haxe.lang.Null<bool>))) {
								newX1 = intersectPoint.x;
								newY1 = intersectPoint.y;
								firstDone = true;
							}
							
							if (global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, this._width, ((double) (0) ), this._width, this._height, intersectPoint, null, default(global::haxe.lang.Null<bool>))) {
								if ( ! (firstDone) ) {
									newX1 = intersectPoint.x;
									newY1 = intersectPoint.y;
									firstDone = true;
								}
								else {
									newX2 = intersectPoint.x;
									newY2 = intersectPoint.y;
									secondDone = true;
								}
								
							}
							
							if ((  ! (secondDone)  && global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, ((double) (0) ), this._height, this._width, this._height, intersectPoint, null, default(global::haxe.lang.Null<bool>)) )) {
								if ( ! (firstDone) ) {
									newX1 = intersectPoint.x;
									newY1 = intersectPoint.y;
									firstDone = true;
								}
								else {
									newX2 = intersectPoint.x;
									newY2 = intersectPoint.y;
									secondDone = true;
								}
								
							}
							
							if ((  ! (secondDone)  && global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, ((double) (0) ), ((double) (0) ), ((double) (0) ), this._height, intersectPoint, null, default(global::haxe.lang.Null<bool>)) )) {
								newX2 = intersectPoint.x;
								newY2 = intersectPoint.y;
							}
							
							if ( ! (firstDone) ) {
								return null;
							}
							
						}
						
					}
					else {
						if (( ( p1pos == 2 ) || ( p2pos == 2 ) )) {
							global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, ((double) (0) ), ((double) (0) ), this._width, ((double) (0) ), intersectPoint, null, default(global::haxe.lang.Null<bool>));
						}
						else if (( ( p1pos == 4 ) || ( p2pos == 4 ) )) {
							global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, this._width, ((double) (0) ), this._width, this._height, intersectPoint, null, default(global::haxe.lang.Null<bool>));
						}
						else if (( ( p1pos == 6 ) || ( p2pos == 6 ) )) {
							global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, ((double) (0) ), this._height, this._width, this._height, intersectPoint, null, default(global::haxe.lang.Null<bool>));
						}
						else if (( ( p1pos == 8 ) || ( p2pos == 8 ) )) {
							global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, ((double) (0) ), ((double) (0) ), ((double) (0) ), this._height, intersectPoint, null, default(global::haxe.lang.Null<bool>));
						}
						else if ( ! (global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, ((double) (0) ), ((double) (0) ), this._width, ((double) (0) ), intersectPoint, null, default(global::haxe.lang.Null<bool>))) ) {
							if ( ! (global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, this._width, ((double) (0) ), this._width, this._height, intersectPoint, null, default(global::haxe.lang.Null<bool>))) ) {
								if ( ! (global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, ((double) (0) ), this._height, this._width, this._height, intersectPoint, null, default(global::haxe.lang.Null<bool>))) ) {
									global::hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, ((double) (0) ), ((double) (0) ), ((double) (0) ), this._height, intersectPoint, null, default(global::haxe.lang.Null<bool>));
								}
								
							}
							
						}
						
						if (( p1pos == 0 )) {
							newX1 = x1;
							newY1 = y1;
						}
						else {
							newX1 = x2;
							newY1 = y2;
						}
						
						newX2 = intersectPoint.x;
						newY2 = intersectPoint.y;
					}
					
				}
				
				global::hxDaedalus.data.Vertex vertexDown = this.insertVertex(newX1, newY1);
				if (( vertexDown == null )) {
					return null;
				}
				
				global::hxDaedalus.data.Vertex vertexUp = this.insertVertex(newX2, newY2);
				if (( vertexUp == null )) {
					return null;
				}
				
				if (( vertexDown == vertexUp )) {
					return null;
				}
				
				global::hxDaedalus.iterators.FromVertexToOutgoingEdges iterVertexToOutEdges = new global::hxDaedalus.iterators.FromVertexToOutgoingEdges();
				global::hxDaedalus.data.Edge currEdge = null;
				int i = default(int);
				global::hxDaedalus.data.ConstraintSegment segment = new global::hxDaedalus.data.ConstraintSegment();
				global::hxDaedalus.data.Edge tempEdgeDownUp = new global::hxDaedalus.data.Edge();
				global::hxDaedalus.data.Edge tempSdgeUpDown = new global::hxDaedalus.data.Edge();
				tempEdgeDownUp.setDatas(vertexDown, tempSdgeUpDown, null, null, new global::haxe.lang.Null<bool>(true, true), new global::haxe.lang.Null<bool>(true, true));
				tempSdgeUpDown.setDatas(vertexUp, tempEdgeDownUp, null, null, new global::haxe.lang.Null<bool>(true, true), new global::haxe.lang.Null<bool>(true, true));
				global::HxArray<object> intersectedEdges = new global::HxArray<object>();
				global::HxArray<object> leftBoundingEdges = new global::HxArray<object>();
				global::HxArray<object> rightBoundingEdges = new global::HxArray<object>();
				global::hxDaedalus.data.math.Point2D pIntersect = new global::hxDaedalus.data.math.Point2D(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
				global::hxDaedalus.data.Edge edgeLeft = null;
				global::hxDaedalus.data.Edge newEdgeDownUp = null;
				global::hxDaedalus.data.Edge newEdgeUpDown = null;
				bool done = default(bool);
				global::hxDaedalus.data.Vertex currVertex = vertexDown;
				global::hxDaedalus.data.math.Intersection currObjet = global::hxDaedalus.data.math.Intersection.EVertex(currVertex);
				while (true) {
					done = false;
					switch (currObjet._hx_index) {
						case 0:
						{
							global::hxDaedalus.data.Vertex vertex = ( currObjet as global::hxDaedalus.data.math.Intersection_EVertex ).vertex;
							{
								currVertex = vertex;
								iterVertexToOutEdges.set_fromVertex(currVertex);
								while (true) {
									currEdge = iterVertexToOutEdges.next();
									if ( ! ((( currEdge != null ))) ) {
										break;
									}
									
									if (( currEdge.get_destinationVertex() == vertexUp )) {
										if ( ! (currEdge.get_isConstrained()) ) {
											currEdge.set_isConstrained(true);
											currEdge.get_oppositeEdge().set_isConstrained(true);
										}
										
										currEdge.addFromConstraintSegment(segment);
										currEdge.get_oppositeEdge().fromConstraintSegments = currEdge.fromConstraintSegments;
										vertexDown.addFromConstraintSegment(segment);
										vertexUp.addFromConstraintSegment(segment);
										segment.addEdge(currEdge);
										return segment;
									}
									
									if (( global::hxDaedalus.data.math.Geom2D.distanceSquaredVertexToEdge(currEdge.get_destinationVertex(), tempEdgeDownUp) <= 0.0001 )) {
										if ( ! (currEdge.get_isConstrained()) ) {
											currEdge.set_isConstrained(true);
											currEdge.get_oppositeEdge().set_isConstrained(true);
										}
										
										currEdge.addFromConstraintSegment(segment);
										currEdge.get_oppositeEdge().fromConstraintSegments = currEdge.fromConstraintSegments;
										vertexDown.addFromConstraintSegment(segment);
										segment.addEdge(currEdge);
										vertexDown = currEdge.get_destinationVertex();
										tempEdgeDownUp.set_originVertex(vertexDown);
										currObjet = global::hxDaedalus.data.math.Intersection.EVertex(vertexDown);
										done = true;
										break;
									}
									
								}
								
								if (done) {
									continue;
								}
								
								iterVertexToOutEdges.set_fromVertex(currVertex);
								while (true) {
									currEdge = iterVertexToOutEdges.next();
									if ( ! ((( currEdge != null ))) ) {
										break;
									}
									
									currEdge = currEdge.get_nextLeftEdge();
									if (global::hxDaedalus.data.math.Geom2D.intersections2edges(currEdge, tempEdgeDownUp, pIntersect, null, default(global::haxe.lang.Null<bool>))) {
										if (currEdge.get_isConstrained()) {
											vertexDown = this.splitEdge(currEdge, pIntersect.x, pIntersect.y);
											iterVertexToOutEdges.set_fromVertex(currVertex);
											while (true) {
												currEdge = iterVertexToOutEdges.next();
												if ( ! ((( currEdge != null ))) ) {
													break;
												}
												
												if (( currEdge.get_destinationVertex() == vertexDown )) {
													currEdge.set_isConstrained(true);
													currEdge.get_oppositeEdge().set_isConstrained(true);
													currEdge.addFromConstraintSegment(segment);
													currEdge.get_oppositeEdge().fromConstraintSegments = currEdge.fromConstraintSegments;
													segment.addEdge(currEdge);
													break;
												}
												
											}
											
											currVertex.addFromConstraintSegment(segment);
											tempEdgeDownUp.set_originVertex(vertexDown);
											currObjet = global::hxDaedalus.data.math.Intersection.EVertex(vertexDown);
										}
										else {
											intersectedEdges.push(currEdge);
											leftBoundingEdges.unshift(currEdge.get_nextLeftEdge());
											rightBoundingEdges.push(currEdge.get_prevLeftEdge());
											currEdge = currEdge.get_oppositeEdge();
											currObjet = global::hxDaedalus.data.math.Intersection.EEdge(currEdge);
										}
										
										break;
									}
									
								}
								
							}
							
							break;
						}
						
						
						case 1:
						{
							global::hxDaedalus.data.Edge edge = ( currObjet as global::hxDaedalus.data.math.Intersection_EEdge ).edge;
							{
								currEdge = edge;
								edgeLeft = currEdge.get_nextLeftEdge();
								if (( edgeLeft.get_destinationVertex() == vertexUp )) {
									leftBoundingEdges.unshift(edgeLeft.get_nextLeftEdge());
									rightBoundingEdges.push(edgeLeft);
									newEdgeDownUp = new global::hxDaedalus.data.Edge();
									newEdgeUpDown = new global::hxDaedalus.data.Edge();
									newEdgeDownUp.setDatas(vertexDown, newEdgeUpDown, null, null, new global::haxe.lang.Null<bool>(true, true), new global::haxe.lang.Null<bool>(true, true));
									newEdgeUpDown.setDatas(vertexUp, newEdgeDownUp, null, null, new global::haxe.lang.Null<bool>(true, true), new global::haxe.lang.Null<bool>(true, true));
									leftBoundingEdges.push(newEdgeDownUp);
									rightBoundingEdges.push(newEdgeUpDown);
									this.insertNewConstrainedEdge(segment, newEdgeDownUp, intersectedEdges, leftBoundingEdges, rightBoundingEdges);
									return segment;
								}
								else if (( global::hxDaedalus.data.math.Geom2D.distanceSquaredVertexToEdge(edgeLeft.get_destinationVertex(), tempEdgeDownUp) <= 0.0001 )) {
									leftBoundingEdges.unshift(edgeLeft.get_nextLeftEdge());
									rightBoundingEdges.push(edgeLeft);
									newEdgeDownUp = new global::hxDaedalus.data.Edge();
									newEdgeUpDown = new global::hxDaedalus.data.Edge();
									newEdgeDownUp.setDatas(vertexDown, newEdgeUpDown, null, null, new global::haxe.lang.Null<bool>(true, true), new global::haxe.lang.Null<bool>(true, true));
									newEdgeUpDown.setDatas(edgeLeft.get_destinationVertex(), newEdgeDownUp, null, null, new global::haxe.lang.Null<bool>(true, true), new global::haxe.lang.Null<bool>(true, true));
									leftBoundingEdges.push(newEdgeDownUp);
									rightBoundingEdges.push(newEdgeUpDown);
									this.insertNewConstrainedEdge(segment, newEdgeDownUp, intersectedEdges, leftBoundingEdges, rightBoundingEdges);
									intersectedEdges.spliceVoid(0, intersectedEdges.length);
									leftBoundingEdges.spliceVoid(0, leftBoundingEdges.length);
									rightBoundingEdges.spliceVoid(0, rightBoundingEdges.length);
									vertexDown = edgeLeft.get_destinationVertex();
									tempEdgeDownUp.set_originVertex(vertexDown);
									currObjet = global::hxDaedalus.data.math.Intersection.EVertex(vertexDown);
								}
								else if (global::hxDaedalus.data.math.Geom2D.intersections2edges(edgeLeft, tempEdgeDownUp, pIntersect, null, default(global::haxe.lang.Null<bool>))) {
									if (edgeLeft.get_isConstrained()) {
										currVertex = this.splitEdge(edgeLeft, pIntersect.x, pIntersect.y);
										iterVertexToOutEdges.set_fromVertex(currVertex);
										while (true) {
											currEdge = iterVertexToOutEdges.next();
											if ( ! ((( currEdge != null ))) ) {
												break;
											}
											
											if (( currEdge.get_destinationVertex() == ((global::hxDaedalus.data.Edge) (leftBoundingEdges[0]) ).get_originVertex() )) {
												leftBoundingEdges.unshift(currEdge);
											}
											
											if (( currEdge.get_destinationVertex() == ((global::hxDaedalus.data.Edge) (rightBoundingEdges[( rightBoundingEdges.length - 1 )]) ).get_destinationVertex() )) {
												rightBoundingEdges.push(currEdge.get_oppositeEdge());
											}
											
										}
										
										newEdgeDownUp = new global::hxDaedalus.data.Edge();
										newEdgeUpDown = new global::hxDaedalus.data.Edge();
										newEdgeDownUp.setDatas(vertexDown, newEdgeUpDown, null, null, new global::haxe.lang.Null<bool>(true, true), new global::haxe.lang.Null<bool>(true, true));
										newEdgeUpDown.setDatas(currVertex, newEdgeDownUp, null, null, new global::haxe.lang.Null<bool>(true, true), new global::haxe.lang.Null<bool>(true, true));
										leftBoundingEdges.push(newEdgeDownUp);
										rightBoundingEdges.push(newEdgeUpDown);
										this.insertNewConstrainedEdge(segment, newEdgeDownUp, intersectedEdges, leftBoundingEdges, rightBoundingEdges);
										intersectedEdges.spliceVoid(0, intersectedEdges.length);
										leftBoundingEdges.spliceVoid(0, leftBoundingEdges.length);
										rightBoundingEdges.spliceVoid(0, rightBoundingEdges.length);
										vertexDown = currVertex;
										tempEdgeDownUp.set_originVertex(vertexDown);
										currObjet = global::hxDaedalus.data.math.Intersection.EVertex(vertexDown);
									}
									else {
										intersectedEdges.push(edgeLeft);
										leftBoundingEdges.unshift(edgeLeft.get_nextLeftEdge());
										currEdge = edgeLeft.get_oppositeEdge();
										currObjet = global::hxDaedalus.data.math.Intersection.EEdge(currEdge);
									}
									
								}
								else {
									edgeLeft = edgeLeft.get_nextLeftEdge();
									global::hxDaedalus.data.math.Geom2D.intersections2edges(edgeLeft, tempEdgeDownUp, pIntersect, null, default(global::haxe.lang.Null<bool>));
									if (edgeLeft.get_isConstrained()) {
										currVertex = this.splitEdge(edgeLeft, pIntersect.x, pIntersect.y);
										iterVertexToOutEdges.set_fromVertex(currVertex);
										while (true) {
											currEdge = iterVertexToOutEdges.next();
											if ( ! ((( currEdge != null ))) ) {
												break;
											}
											
											if (( currEdge.get_destinationVertex() == ((global::hxDaedalus.data.Edge) (leftBoundingEdges[0]) ).get_originVertex() )) {
												leftBoundingEdges.unshift(currEdge);
											}
											
											if (( currEdge.get_destinationVertex() == ((global::hxDaedalus.data.Edge) (rightBoundingEdges[( rightBoundingEdges.length - 1 )]) ).get_destinationVertex() )) {
												rightBoundingEdges.push(currEdge.get_oppositeEdge());
											}
											
										}
										
										newEdgeDownUp = new global::hxDaedalus.data.Edge();
										newEdgeUpDown = new global::hxDaedalus.data.Edge();
										newEdgeDownUp.setDatas(vertexDown, newEdgeUpDown, null, null, new global::haxe.lang.Null<bool>(true, true), new global::haxe.lang.Null<bool>(true, true));
										newEdgeUpDown.setDatas(currVertex, newEdgeDownUp, null, null, new global::haxe.lang.Null<bool>(true, true), new global::haxe.lang.Null<bool>(true, true));
										leftBoundingEdges.push(newEdgeDownUp);
										rightBoundingEdges.push(newEdgeUpDown);
										this.insertNewConstrainedEdge(segment, newEdgeDownUp, intersectedEdges, leftBoundingEdges, rightBoundingEdges);
										intersectedEdges.spliceVoid(0, intersectedEdges.length);
										leftBoundingEdges.spliceVoid(0, leftBoundingEdges.length);
										rightBoundingEdges.spliceVoid(0, rightBoundingEdges.length);
										vertexDown = currVertex;
										tempEdgeDownUp.set_originVertex(vertexDown);
										currObjet = global::hxDaedalus.data.math.Intersection.EVertex(vertexDown);
									}
									else {
										intersectedEdges.push(edgeLeft);
										rightBoundingEdges.push(edgeLeft.get_prevLeftEdge());
										currEdge = edgeLeft.get_oppositeEdge();
										currObjet = global::hxDaedalus.data.math.Intersection.EEdge(currEdge);
									}
									
								}
								
							}
							
							break;
						}
						
						
						case 2:
						{
							global::hxDaedalus.data.Face face = ( currObjet as global::hxDaedalus.data.math.Intersection_EFace ).face;
							break;
						}
						
						
						case 3:
						{
							break;
						}
						
						
					}
					
				}
				
				return null;
			}
		}
		
		
		public virtual void insertNewConstrainedEdge(global::hxDaedalus.data.ConstraintSegment fromSegment, global::hxDaedalus.data.Edge edgeDownUp, global::HxArray<object> intersectedEdges, global::HxArray<object> leftBoundingEdges, global::HxArray<object> rightBoundingEdges) {
			this._edges.push(edgeDownUp);
			this._edges.push(edgeDownUp.get_oppositeEdge());
			edgeDownUp.addFromConstraintSegment(fromSegment);
			edgeDownUp.get_oppositeEdge().fromConstraintSegments = edgeDownUp.fromConstraintSegments;
			fromSegment.addEdge(edgeDownUp);
			edgeDownUp.get_originVertex().addFromConstraintSegment(fromSegment);
			edgeDownUp.get_destinationVertex().addFromConstraintSegment(fromSegment);
			this.untriangulate(intersectedEdges);
			this.triangulate(leftBoundingEdges, true);
			this.triangulate(rightBoundingEdges, true);
		}
		
		
		public virtual void deleteConstraintSegment(global::hxDaedalus.data.ConstraintSegment segment) {
			int i = default(int);
			global::HxArray<object> vertexToDelete = new global::HxArray<object>();
			global::hxDaedalus.data.Edge edge = null;
			global::hxDaedalus.data.Vertex vertex = null;
			global::HxArray<object> fromConstraintSegment = null;
			{
				int _g = 0;
				int _g1 = segment.get_edges().length;
				while (( _g < _g1 )) {
					int i1 = _g++;
					edge = ((global::hxDaedalus.data.Edge) (segment.get_edges()[i1]) );
					edge.removeFromConstraintSegment(segment);
					if (( edge.fromConstraintSegments.length == 0 )) {
						edge.set_isConstrained(false);
						edge.get_oppositeEdge().set_isConstrained(false);
					}
					
					vertex = edge.get_originVertex();
					vertex.removeFromConstraintSegment(segment);
					vertexToDelete.push(vertex);
				}
				
			}
			
			vertex = edge.get_destinationVertex();
			vertex.removeFromConstraintSegment(segment);
			vertexToDelete.push(vertex);
			{
				int _g2 = 0;
				int _g3 = vertexToDelete.length;
				while (( _g2 < _g3 )) {
					int i2 = _g2++;
					this.deleteVertex(((global::hxDaedalus.data.Vertex) (vertexToDelete[i2]) ));
				}
				
			}
			
			segment.dispose();
		}
		
		
		public virtual void check() {
			int _g = 0;
			int _g1 = this._edges.length;
			while (( _g < _g1 )) {
				int i = _g++;
				if (( ((global::hxDaedalus.data.Edge) (this._edges[i]) ).get_nextLeftEdge() == null )) {
					return;
				}
				
			}
			
		}
		
		
		public virtual global::hxDaedalus.data.Vertex insertVertex(double x, double y) {
			unchecked {
				if (( ( ( ( x < 0 ) || ( y < 0 ) ) || ( x > this._width ) ) || ( y > this._height ) )) {
					return null;
				}
				
				this.__edgesToCheck.spliceVoid(0, this.__edgesToCheck.length);
				global::hxDaedalus.data.math.Intersection inObject = global::hxDaedalus.data.math.Geom2D.locatePosition(x, y, this);
				global::hxDaedalus.data.Vertex newVertex = null;
				switch (inObject._hx_index) {
					case 0:
					{
						global::hxDaedalus.data.Vertex vertex = ( inObject as global::hxDaedalus.data.math.Intersection_EVertex ).vertex;
						newVertex = vertex;
						break;
					}
					
					
					case 1:
					{
						global::hxDaedalus.data.Edge edge = ( inObject as global::hxDaedalus.data.math.Intersection_EEdge ).edge;
						newVertex = this.splitEdge(edge, x, y);
						break;
					}
					
					
					case 2:
					{
						global::hxDaedalus.data.Face face = ( inObject as global::hxDaedalus.data.math.Intersection_EFace ).face;
						newVertex = this.splitFace(face, x, y);
						break;
					}
					
					
					case 3:
					{
						break;
					}
					
					
				}
				
				this.restoreAsDelaunay();
				return newVertex;
			}
		}
		
		
		public virtual global::hxDaedalus.data.Edge flipEdge(global::hxDaedalus.data.Edge edge) {
			unchecked {
				global::hxDaedalus.data.Edge eBot_Top = edge;
				global::hxDaedalus.data.Edge eTop_Bot = edge.get_oppositeEdge();
				global::hxDaedalus.data.Edge eLeft_Right = new global::hxDaedalus.data.Edge();
				global::hxDaedalus.data.Edge eRight_Left = new global::hxDaedalus.data.Edge();
				global::hxDaedalus.data.Edge eTop_Left = eBot_Top.get_nextLeftEdge();
				global::hxDaedalus.data.Edge eLeft_Bot = eTop_Left.get_nextLeftEdge();
				global::hxDaedalus.data.Edge eBot_Right = eTop_Bot.get_nextLeftEdge();
				global::hxDaedalus.data.Edge eRight_Top = eBot_Right.get_nextLeftEdge();
				global::hxDaedalus.data.Vertex vBot = eBot_Top.get_originVertex();
				global::hxDaedalus.data.Vertex vTop = eTop_Bot.get_originVertex();
				global::hxDaedalus.data.Vertex vLeft = eLeft_Bot.get_originVertex();
				global::hxDaedalus.data.Vertex vRight = eRight_Top.get_originVertex();
				global::hxDaedalus.data.Face fLeft = eBot_Top.get_leftFace();
				global::hxDaedalus.data.Face fRight = eTop_Bot.get_leftFace();
				global::hxDaedalus.data.Face fBot = new global::hxDaedalus.data.Face();
				global::hxDaedalus.data.Face fTop = new global::hxDaedalus.data.Face();
				this._edges.push(eLeft_Right);
				this._edges.push(eRight_Left);
				this._faces.push(fTop);
				this._faces.push(fBot);
				eLeft_Right.setDatas(vLeft, eRight_Left, eRight_Top, fTop, new global::haxe.lang.Null<bool>(edge.get_isReal(), true), new global::haxe.lang.Null<bool>(edge.get_isConstrained(), true));
				eRight_Left.setDatas(vRight, eLeft_Right, eLeft_Bot, fBot, new global::haxe.lang.Null<bool>(edge.get_isReal(), true), new global::haxe.lang.Null<bool>(edge.get_isConstrained(), true));
				fTop.setDatas(eLeft_Right, default(global::haxe.lang.Null<bool>));
				fBot.setDatas(eRight_Left, default(global::haxe.lang.Null<bool>));
				if (( vTop.get_edge() == eTop_Bot )) {
					vTop.setDatas(eTop_Left, default(global::haxe.lang.Null<bool>));
				}
				
				if (( vBot.get_edge() == eBot_Top )) {
					vBot.setDatas(eBot_Right, default(global::haxe.lang.Null<bool>));
				}
				
				eTop_Left.set_nextLeftEdge(eLeft_Right);
				eTop_Left.set_leftFace(fTop);
				eLeft_Bot.set_nextLeftEdge(eBot_Right);
				eLeft_Bot.set_leftFace(fBot);
				eBot_Right.set_nextLeftEdge(eRight_Left);
				eBot_Right.set_leftFace(fBot);
				eRight_Top.set_nextLeftEdge(eTop_Left);
				eRight_Top.set_leftFace(fTop);
				eBot_Top.dispose();
				eTop_Bot.dispose();
				this._edges.spliceVoid(this._edges.indexOf(eBot_Top, default(global::haxe.lang.Null<int>)), 1);
				this._edges.spliceVoid(this._edges.indexOf(eTop_Bot, default(global::haxe.lang.Null<int>)), 1);
				fLeft.dispose();
				fRight.dispose();
				this._faces.spliceVoid(this._faces.indexOf(fLeft, default(global::haxe.lang.Null<int>)), 1);
				this._faces.spliceVoid(this._faces.indexOf(fRight, default(global::haxe.lang.Null<int>)), 1);
				return eRight_Left;
			}
		}
		
		
		public virtual global::hxDaedalus.data.Vertex splitEdge(global::hxDaedalus.data.Edge edge, double x, double y) {
			unchecked {
				this.__edgesToCheck.spliceVoid(0, this.__edgesToCheck.length);
				global::hxDaedalus.data.Edge eLeft_Right = edge;
				global::hxDaedalus.data.Edge eRight_Left = eLeft_Right.get_oppositeEdge();
				global::hxDaedalus.data.Edge eRight_Top = eLeft_Right.get_nextLeftEdge();
				global::hxDaedalus.data.Edge eTop_Left = eRight_Top.get_nextLeftEdge();
				global::hxDaedalus.data.Edge eLeft_Bot = eRight_Left.get_nextLeftEdge();
				global::hxDaedalus.data.Edge eBot_Right = eLeft_Bot.get_nextLeftEdge();
				global::hxDaedalus.data.Vertex vTop = eTop_Left.get_originVertex();
				global::hxDaedalus.data.Vertex vLeft = eLeft_Right.get_originVertex();
				global::hxDaedalus.data.Vertex vBot = eBot_Right.get_originVertex();
				global::hxDaedalus.data.Vertex vRight = eRight_Left.get_originVertex();
				global::hxDaedalus.data.Face fTop = eLeft_Right.get_leftFace();
				global::hxDaedalus.data.Face fBot = eRight_Left.get_leftFace();
				if (( ( ( (( vLeft.get_pos().x - x )) * (( vLeft.get_pos().x - x )) ) + ( (( vLeft.get_pos().y - y )) * (( vLeft.get_pos().y - y )) ) ) <= 0.0001 )) {
					return vLeft;
				}
				
				if (( ( ( (( vRight.get_pos().x - x )) * (( vRight.get_pos().x - x )) ) + ( (( vRight.get_pos().y - y )) * (( vRight.get_pos().y - y )) ) ) <= 0.0001 )) {
					return vRight;
				}
				
				global::hxDaedalus.data.Vertex vCenter = new global::hxDaedalus.data.Vertex();
				global::hxDaedalus.data.Edge eTop_Center = new global::hxDaedalus.data.Edge();
				global::hxDaedalus.data.Edge eCenter_Top = new global::hxDaedalus.data.Edge();
				global::hxDaedalus.data.Edge eBot_Center = new global::hxDaedalus.data.Edge();
				global::hxDaedalus.data.Edge eCenter_Bot = new global::hxDaedalus.data.Edge();
				global::hxDaedalus.data.Edge eLeft_Center = new global::hxDaedalus.data.Edge();
				global::hxDaedalus.data.Edge eCenter_Left = new global::hxDaedalus.data.Edge();
				global::hxDaedalus.data.Edge eRight_Center = new global::hxDaedalus.data.Edge();
				global::hxDaedalus.data.Edge eCenter_Right = new global::hxDaedalus.data.Edge();
				global::hxDaedalus.data.Face fTopLeft = new global::hxDaedalus.data.Face();
				global::hxDaedalus.data.Face fBotLeft = new global::hxDaedalus.data.Face();
				global::hxDaedalus.data.Face fBotRight = new global::hxDaedalus.data.Face();
				global::hxDaedalus.data.Face fTopRight = new global::hxDaedalus.data.Face();
				this._vertices.push(vCenter);
				this._edges.push(eCenter_Top);
				this._edges.push(eTop_Center);
				this._edges.push(eCenter_Left);
				this._edges.push(eLeft_Center);
				this._edges.push(eCenter_Bot);
				this._edges.push(eBot_Center);
				this._edges.push(eCenter_Right);
				this._edges.push(eRight_Center);
				this._faces.push(fTopRight);
				this._faces.push(fBotRight);
				this._faces.push(fBotLeft);
				this._faces.push(fTopLeft);
				vCenter.setDatas(( (fTop.get_isReal()) ? (eCenter_Top) : (eCenter_Bot) ), default(global::haxe.lang.Null<bool>));
				vCenter.get_pos().x = x;
				vCenter.get_pos().y = y;
				global::hxDaedalus.data.math.Geom2D.projectOrthogonaly(vCenter.get_pos(), eLeft_Right);
				eCenter_Top.setDatas(vCenter, eTop_Center, eTop_Left, fTopLeft, new global::haxe.lang.Null<bool>(fTop.get_isReal(), true), default(global::haxe.lang.Null<bool>));
				eTop_Center.setDatas(vTop, eCenter_Top, eCenter_Right, fTopRight, new global::haxe.lang.Null<bool>(fTop.get_isReal(), true), default(global::haxe.lang.Null<bool>));
				eCenter_Left.setDatas(vCenter, eLeft_Center, eLeft_Bot, fBotLeft, new global::haxe.lang.Null<bool>(edge.get_isReal(), true), new global::haxe.lang.Null<bool>(edge.get_isConstrained(), true));
				eLeft_Center.setDatas(vLeft, eCenter_Left, eCenter_Top, fTopLeft, new global::haxe.lang.Null<bool>(edge.get_isReal(), true), new global::haxe.lang.Null<bool>(edge.get_isConstrained(), true));
				eCenter_Bot.setDatas(vCenter, eBot_Center, eBot_Right, fBotRight, new global::haxe.lang.Null<bool>(fBot.get_isReal(), true), default(global::haxe.lang.Null<bool>));
				eBot_Center.setDatas(vBot, eCenter_Bot, eCenter_Left, fBotLeft, new global::haxe.lang.Null<bool>(fBot.get_isReal(), true), default(global::haxe.lang.Null<bool>));
				eCenter_Right.setDatas(vCenter, eRight_Center, eRight_Top, fTopRight, new global::haxe.lang.Null<bool>(edge.get_isReal(), true), new global::haxe.lang.Null<bool>(edge.get_isConstrained(), true));
				eRight_Center.setDatas(vRight, eCenter_Right, eCenter_Bot, fBotRight, new global::haxe.lang.Null<bool>(edge.get_isReal(), true), new global::haxe.lang.Null<bool>(edge.get_isConstrained(), true));
				fTopLeft.setDatas(eCenter_Top, new global::haxe.lang.Null<bool>(fTop.get_isReal(), true));
				fBotLeft.setDatas(eCenter_Left, new global::haxe.lang.Null<bool>(fBot.get_isReal(), true));
				fBotRight.setDatas(eCenter_Bot, new global::haxe.lang.Null<bool>(fBot.get_isReal(), true));
				fTopRight.setDatas(eCenter_Right, new global::haxe.lang.Null<bool>(fTop.get_isReal(), true));
				if (( vLeft.get_edge() == eLeft_Right )) {
					vLeft.setDatas(eLeft_Center, default(global::haxe.lang.Null<bool>));
				}
				
				if (( vRight.get_edge() == eRight_Left )) {
					vRight.setDatas(eRight_Center, default(global::haxe.lang.Null<bool>));
				}
				
				eTop_Left.set_nextLeftEdge(eLeft_Center);
				eTop_Left.set_leftFace(fTopLeft);
				eLeft_Bot.set_nextLeftEdge(eBot_Center);
				eLeft_Bot.set_leftFace(fBotLeft);
				eBot_Right.set_nextLeftEdge(eRight_Center);
				eBot_Right.set_leftFace(fBotRight);
				eRight_Top.set_nextLeftEdge(eTop_Center);
				eRight_Top.set_leftFace(fTopRight);
				if (eLeft_Right.get_isConstrained()) {
					global::HxArray<object> fromSegments = eLeft_Right.fromConstraintSegments;
					eLeft_Center.fromConstraintSegments = fromSegments.slice(0, default(global::haxe.lang.Null<int>));
					eCenter_Left.fromConstraintSegments = eLeft_Center.fromConstraintSegments;
					eCenter_Right.fromConstraintSegments = fromSegments.slice(0, default(global::haxe.lang.Null<int>));
					eRight_Center.fromConstraintSegments = eCenter_Right.fromConstraintSegments;
					global::HxArray<object> edges = null;
					int index = default(int);
					{
						int _g = 0;
						int _g1 = eLeft_Right.fromConstraintSegments.length;
						while (( _g < _g1 )) {
							int i = _g++;
							edges = ((global::hxDaedalus.data.ConstraintSegment) (eLeft_Right.fromConstraintSegments[i]) ).get_edges();
							index = edges.indexOf(eLeft_Right, default(global::haxe.lang.Null<int>));
							if (( index != -1 )) {
								edges.spliceVoid(index, 1);
								edges.insert(index, eLeft_Center);
								edges.insert(( index + 1 ), eCenter_Right);
							}
							else {
								index = edges.indexOf(eRight_Left, default(global::haxe.lang.Null<int>));
								edges.spliceVoid(index, 1);
								edges.insert(index, eRight_Center);
								edges.insert(( index + 1 ), eCenter_Left);
							}
							
						}
						
					}
					
					vCenter.set_fromConstraintSegments(fromSegments.slice(0, default(global::haxe.lang.Null<int>)));
				}
				
				eLeft_Right.dispose();
				eRight_Left.dispose();
				this._edges.spliceVoid(this._edges.indexOf(eLeft_Right, default(global::haxe.lang.Null<int>)), 1);
				this._edges.spliceVoid(this._edges.indexOf(eRight_Left, default(global::haxe.lang.Null<int>)), 1);
				fTop.dispose();
				fBot.dispose();
				this._faces.spliceVoid(this._faces.indexOf(fTop, default(global::haxe.lang.Null<int>)), 1);
				this._faces.spliceVoid(this._faces.indexOf(fBot, default(global::haxe.lang.Null<int>)), 1);
				this.__centerVertex = vCenter;
				this.__edgesToCheck.push(eTop_Left);
				this.__edgesToCheck.push(eLeft_Bot);
				this.__edgesToCheck.push(eBot_Right);
				this.__edgesToCheck.push(eRight_Top);
				return vCenter;
			}
		}
		
		
		public virtual global::hxDaedalus.data.Vertex splitFace(global::hxDaedalus.data.Face face, double x, double y) {
			unchecked {
				this.__edgesToCheck.spliceVoid(0, this.__edgesToCheck.length);
				global::hxDaedalus.data.Edge eTop_Left = face.get_edge();
				global::hxDaedalus.data.Edge eLeft_Right = eTop_Left.get_nextLeftEdge();
				global::hxDaedalus.data.Edge eRight_Top = eLeft_Right.get_nextLeftEdge();
				global::hxDaedalus.data.Vertex vTop = eTop_Left.get_originVertex();
				global::hxDaedalus.data.Vertex vLeft = eLeft_Right.get_originVertex();
				global::hxDaedalus.data.Vertex vRight = eRight_Top.get_originVertex();
				global::hxDaedalus.data.Vertex vCenter = new global::hxDaedalus.data.Vertex();
				global::hxDaedalus.data.Edge eTop_Center = new global::hxDaedalus.data.Edge();
				global::hxDaedalus.data.Edge eCenter_Top = new global::hxDaedalus.data.Edge();
				global::hxDaedalus.data.Edge eLeft_Center = new global::hxDaedalus.data.Edge();
				global::hxDaedalus.data.Edge eCenter_Left = new global::hxDaedalus.data.Edge();
				global::hxDaedalus.data.Edge eRight_Center = new global::hxDaedalus.data.Edge();
				global::hxDaedalus.data.Edge eCenter_Right = new global::hxDaedalus.data.Edge();
				global::hxDaedalus.data.Face fTopLeft = new global::hxDaedalus.data.Face();
				global::hxDaedalus.data.Face fBot = new global::hxDaedalus.data.Face();
				global::hxDaedalus.data.Face fTopRight = new global::hxDaedalus.data.Face();
				this._vertices.push(vCenter);
				this._edges.push(eTop_Center);
				this._edges.push(eCenter_Top);
				this._edges.push(eLeft_Center);
				this._edges.push(eCenter_Left);
				this._edges.push(eRight_Center);
				this._edges.push(eCenter_Right);
				this._faces.push(fTopLeft);
				this._faces.push(fBot);
				this._faces.push(fTopRight);
				vCenter.setDatas(eCenter_Top, default(global::haxe.lang.Null<bool>));
				vCenter.get_pos().x = x;
				vCenter.get_pos().y = y;
				eTop_Center.setDatas(vTop, eCenter_Top, eCenter_Right, fTopRight, default(global::haxe.lang.Null<bool>), default(global::haxe.lang.Null<bool>));
				eCenter_Top.setDatas(vCenter, eTop_Center, eTop_Left, fTopLeft, default(global::haxe.lang.Null<bool>), default(global::haxe.lang.Null<bool>));
				eLeft_Center.setDatas(vLeft, eCenter_Left, eCenter_Top, fTopLeft, default(global::haxe.lang.Null<bool>), default(global::haxe.lang.Null<bool>));
				eCenter_Left.setDatas(vCenter, eLeft_Center, eLeft_Right, fBot, default(global::haxe.lang.Null<bool>), default(global::haxe.lang.Null<bool>));
				eRight_Center.setDatas(vRight, eCenter_Right, eCenter_Left, fBot, default(global::haxe.lang.Null<bool>), default(global::haxe.lang.Null<bool>));
				eCenter_Right.setDatas(vCenter, eRight_Center, eRight_Top, fTopRight, default(global::haxe.lang.Null<bool>), default(global::haxe.lang.Null<bool>));
				fTopLeft.setDatas(eCenter_Top, default(global::haxe.lang.Null<bool>));
				fBot.setDatas(eCenter_Left, default(global::haxe.lang.Null<bool>));
				fTopRight.setDatas(eCenter_Right, default(global::haxe.lang.Null<bool>));
				eTop_Left.set_nextLeftEdge(eLeft_Center);
				eTop_Left.set_leftFace(fTopLeft);
				eLeft_Right.set_nextLeftEdge(eRight_Center);
				eLeft_Right.set_leftFace(fBot);
				eRight_Top.set_nextLeftEdge(eTop_Center);
				eRight_Top.set_leftFace(fTopRight);
				face.dispose();
				this._faces.spliceVoid(this._faces.indexOf(face, default(global::haxe.lang.Null<int>)), 1);
				this.__centerVertex = vCenter;
				this.__edgesToCheck.push(eTop_Left);
				this.__edgesToCheck.push(eLeft_Right);
				this.__edgesToCheck.push(eRight_Top);
				return vCenter;
			}
		}
		
		
		public virtual void restoreAsDelaunay() {
			global::hxDaedalus.data.Edge edge = null;
			while (( this.__edgesToCheck.length > 0 )) {
				edge = ((global::hxDaedalus.data.Edge) ((this.__edgesToCheck.shift()).@value) );
				if (( ( edge.get_isReal() &&  ! (edge.get_isConstrained())  ) &&  ! (global::hxDaedalus.data.math.Geom2D.isDelaunay(edge))  )) {
					if (( edge.get_nextLeftEdge().get_destinationVertex() == this.__centerVertex )) {
						this.__edgesToCheck.push(edge.get_nextRightEdge());
						this.__edgesToCheck.push(edge.get_prevRightEdge());
					}
					else {
						this.__edgesToCheck.push(edge.get_nextLeftEdge());
						this.__edgesToCheck.push(edge.get_prevLeftEdge());
					}
					
					this.flipEdge(edge);
				}
				
			}
			
		}
		
		
		public virtual bool deleteVertex(global::hxDaedalus.data.Vertex vertex) {
			unchecked {
				int i = default(int);
				global::hxDaedalus.iterators.FromVertexToOutgoingEdges iterEdges = new global::hxDaedalus.iterators.FromVertexToOutgoingEdges();
				iterEdges.set_fromVertex(vertex);
				iterEdges.realEdgesOnly = false;
				global::hxDaedalus.data.Edge edge = null;
				global::HxArray<object> outgoingEdges = new global::HxArray<object>();
				bool freeOfConstraint = ( vertex.get_fromConstraintSegments().length == 0 );
				global::HxArray<object> bound = new global::HxArray<object>();
				bool realA = false;
				bool realB = false;
				global::HxArray<object> boundA = new global::HxArray<object>(new object[]{});
				global::HxArray<object> boundB = new global::HxArray<object>(new object[]{});
				if (freeOfConstraint) {
					while (true) {
						edge = iterEdges.next();
						if ( ! ((( edge != null ))) ) {
							break;
						}
						
						outgoingEdges.push(edge);
						bound.push(edge.get_nextLeftEdge());
					}
					
				}
				else {
					global::HxArray<object> edges = null;
					{
						int _g = 0;
						int _g1 = vertex.get_fromConstraintSegments().length;
						while (( _g < _g1 )) {
							int i1 = _g++;
							edges = ((global::hxDaedalus.data.ConstraintSegment) (vertex.get_fromConstraintSegments()[i1]) ).get_edges();
							if (( ( ((global::hxDaedalus.data.Edge) (edges[0]) ).get_originVertex() == vertex ) || ( ((global::hxDaedalus.data.Edge) (edges[( edges.length - 1 )]) ).get_destinationVertex() == vertex ) )) {
								return false;
							}
							
						}
						
					}
					
					int count = 0;
					while (true) {
						edge = iterEdges.next();
						if ( ! ((( edge != null ))) ) {
							break;
						}
						
						outgoingEdges.push(edge);
						if (edge.get_isConstrained()) {
							 ++ count;
							if (( count > 2 )) {
								return false;
							}
							
						}
						
					}
					
					boundA = new global::HxArray<object>();
					boundB = new global::HxArray<object>();
					global::hxDaedalus.data.Edge constrainedEdgeA = null;
					global::hxDaedalus.data.Edge constrainedEdgeB = null;
					global::hxDaedalus.data.Edge edgeA = new global::hxDaedalus.data.Edge();
					global::hxDaedalus.data.Edge edgeB = new global::hxDaedalus.data.Edge();
					this._edges.push(edgeA);
					this._edges.push(edgeB);
					{
						int _g2 = 0;
						int _g3 = outgoingEdges.length;
						while (( _g2 < _g3 )) {
							int i2 = _g2++;
							edge = ((global::hxDaedalus.data.Edge) (outgoingEdges[i2]) );
							if (edge.get_isConstrained()) {
								if (( constrainedEdgeA == null )) {
									edgeB.setDatas(edge.get_destinationVertex(), edgeA, null, null, new global::haxe.lang.Null<bool>(true, true), new global::haxe.lang.Null<bool>(true, true));
									boundA.push(edgeA);
									boundA.push(edge.get_nextLeftEdge());
									boundB.push(edgeB);
									constrainedEdgeA = edge;
								}
								else if (( constrainedEdgeB == null )) {
									edgeA.setDatas(edge.get_destinationVertex(), edgeB, null, null, new global::haxe.lang.Null<bool>(true, true), new global::haxe.lang.Null<bool>(true, true));
									boundB.push(edge.get_nextLeftEdge());
									constrainedEdgeB = edge;
								}
								
							}
							else if (( constrainedEdgeA == null )) {
								boundB.push(edge.get_nextLeftEdge());
							}
							else if (( constrainedEdgeB == null )) {
								boundA.push(edge.get_nextLeftEdge());
							}
							else {
								boundB.push(edge.get_nextLeftEdge());
							}
							
						}
						
					}
					
					realA = constrainedEdgeA.get_leftFace().get_isReal();
					realB = constrainedEdgeB.get_leftFace().get_isReal();
					edgeA.fromConstraintSegments = constrainedEdgeA.fromConstraintSegments.slice(0, default(global::haxe.lang.Null<int>));
					edgeB.fromConstraintSegments = edgeA.fromConstraintSegments;
					int index = default(int);
					{
						int _g4 = 0;
						int _g5 = vertex.get_fromConstraintSegments().length;
						while (( _g4 < _g5 )) {
							int i3 = _g4++;
							edges = ((global::hxDaedalus.data.ConstraintSegment) (vertex.get_fromConstraintSegments()[i3]) ).get_edges();
							index = edges.indexOf(constrainedEdgeA, default(global::haxe.lang.Null<int>));
							if (( index != -1 )) {
								edges.spliceVoid(( index - 1 ), 2);
								edges.insert(( index - 1 ), edgeA);
							}
							else {
								int index2 = ( edges.indexOf(constrainedEdgeB, default(global::haxe.lang.Null<int>)) - 1 );
								edges.spliceVoid(index2, 2);
								edges.insert(index2, edgeB);
							}
							
						}
						
					}
					
				}
				
				global::hxDaedalus.data.Face faceToDelete = null;
				{
					int _g6 = 0;
					int _g7 = outgoingEdges.length;
					while (( _g6 < _g7 )) {
						int i4 = _g6++;
						edge = ((global::hxDaedalus.data.Edge) (outgoingEdges[i4]) );
						faceToDelete = edge.get_leftFace();
						this._faces.spliceVoid(this._faces.indexOf(faceToDelete, default(global::haxe.lang.Null<int>)), 1);
						faceToDelete.dispose();
						edge.get_destinationVertex().set_edge(edge.get_nextLeftEdge());
						this._edges.spliceVoid(this._edges.indexOf(edge.get_oppositeEdge(), default(global::haxe.lang.Null<int>)), 1);
						edge.get_oppositeEdge().dispose();
						this._edges.spliceVoid(this._edges.indexOf(edge, default(global::haxe.lang.Null<int>)), 1);
						edge.dispose();
					}
					
				}
				
				this._vertices.spliceVoid(this._vertices.indexOf(vertex, default(global::haxe.lang.Null<int>)), 1);
				vertex.dispose();
				if (freeOfConstraint) {
					this.triangulate(bound, true);
				}
				else {
					this.triangulate(boundA, realA);
					this.triangulate(boundB, realB);
				}
				
				return true;
			}
		}
		
		
		public virtual void untriangulate(global::HxArray<object> edgesList) {
			unchecked {
				int i = default(int);
				global::haxe.ds.ObjectMap<object, bool> verticesCleaned = new global::haxe.ds.ObjectMap<object, bool>();
				global::hxDaedalus.data.Edge currEdge = null;
				global::hxDaedalus.data.Edge outEdge = null;
				{
					int _g = 0;
					int _g1 = edgesList.length;
					while (( _g < _g1 )) {
						int i1 = _g++;
						currEdge = ((global::hxDaedalus.data.Edge) (edgesList[i1]) );
						if ( ! (verticesCleaned.@get(currEdge.get_originVertex()).hasValue) ) {
							currEdge.get_originVertex().set_edge(currEdge.get_prevLeftEdge().get_oppositeEdge());
							verticesCleaned.@set(currEdge.get_originVertex(), true);
						}
						
						if ( ! (verticesCleaned.@get(currEdge.get_destinationVertex()).hasValue) ) {
							currEdge.get_destinationVertex().set_edge(currEdge.get_nextLeftEdge());
							verticesCleaned.@set(currEdge.get_destinationVertex(), true);
						}
						
						this._faces.spliceVoid(this._faces.indexOf(currEdge.get_leftFace(), default(global::haxe.lang.Null<int>)), 1);
						currEdge.get_leftFace().dispose();
						if (( i1 == ( edgesList.length - 1 ) )) {
							this._faces.spliceVoid(this._faces.indexOf(currEdge.get_rightFace(), default(global::haxe.lang.Null<int>)), 1);
							currEdge.get_rightFace().dispose();
						}
						
					}
					
				}
				
				{
					int _g2 = 0;
					int _g3 = edgesList.length;
					while (( _g2 < _g3 )) {
						int i2 = _g2++;
						currEdge = ((global::hxDaedalus.data.Edge) (edgesList[i2]) );
						this._edges.spliceVoid(this._edges.indexOf(currEdge.get_oppositeEdge(), default(global::haxe.lang.Null<int>)), 1);
						this._edges.spliceVoid(this._edges.indexOf(currEdge, default(global::haxe.lang.Null<int>)), 1);
						currEdge.get_oppositeEdge().dispose();
						currEdge.dispose();
					}
					
				}
				
			}
		}
		
		
		public virtual void triangulate(global::HxArray<object> bound, bool isReal) {
			unchecked {
				if (( bound.length < 2 )) {
					return;
				}
				else if (( bound.length == 2 )) {
					object @value = ((object) (global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("  - edge0: ", global::haxe.lang.Runtime.toString(((global::hxDaedalus.data.Edge) (bound[0]) ).get_originVertex().get_id())), " -> "), global::haxe.lang.Runtime.toString(((global::hxDaedalus.data.Edge) (bound[0]) ).get_destinationVertex().get_id()))) );
					object value1 = ((object) (global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("  - edge1: ", global::haxe.lang.Runtime.toString(((global::hxDaedalus.data.Edge) (bound[1]) ).get_originVertex().get_id())), " -> "), global::haxe.lang.Runtime.toString(((global::hxDaedalus.data.Edge) (bound[1]) ).get_destinationVertex().get_id()))) );
					return;
				}
				else if (( bound.length == 3 )) {
					global::hxDaedalus.data.Face f = new global::hxDaedalus.data.Face();
					f.setDatas(((global::hxDaedalus.data.Edge) (bound[0]) ), new global::haxe.lang.Null<bool>(isReal, true));
					this._faces.push(f);
					((global::hxDaedalus.data.Edge) (bound[0]) ).set_leftFace(f);
					((global::hxDaedalus.data.Edge) (bound[1]) ).set_leftFace(f);
					((global::hxDaedalus.data.Edge) (bound[2]) ).set_leftFace(f);
					((global::hxDaedalus.data.Edge) (bound[0]) ).set_nextLeftEdge(((global::hxDaedalus.data.Edge) (bound[1]) ));
					((global::hxDaedalus.data.Edge) (bound[1]) ).set_nextLeftEdge(((global::hxDaedalus.data.Edge) (bound[2]) ));
					((global::hxDaedalus.data.Edge) (bound[2]) ).set_nextLeftEdge(((global::hxDaedalus.data.Edge) (bound[0]) ));
				}
				else {
					global::hxDaedalus.data.Edge baseEdge = ((global::hxDaedalus.data.Edge) (bound[0]) );
					global::hxDaedalus.data.Vertex vertexA = baseEdge.get_originVertex();
					global::hxDaedalus.data.Vertex vertexB = baseEdge.get_destinationVertex();
					global::hxDaedalus.data.Vertex vertexC = null;
					global::hxDaedalus.data.Vertex vertexCheck = null;
					global::hxDaedalus.data.math.Point2D circumcenter = new global::hxDaedalus.data.math.Point2D(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
					double radiusSquared = default(double);
					double distanceSquared = default(double);
					bool isDelaunay = false;
					int index = 0;
					int i = default(int);
					{
						int _g = 2;
						int _g1 = bound.length;
						while (( _g < _g1 )) {
							int i1 = _g++;
							vertexC = ((global::hxDaedalus.data.Edge) (bound[i1]) ).get_originVertex();
							if (( global::hxDaedalus.data.math.Geom2D.getRelativePosition2(vertexC.get_pos().x, vertexC.get_pos().y, baseEdge) == 1 )) {
								index = i1;
								isDelaunay = true;
								global::hxDaedalus.data.math.Geom2D.getCircumcenter(vertexA.get_pos().x, vertexA.get_pos().y, vertexB.get_pos().x, vertexB.get_pos().y, vertexC.get_pos().x, vertexC.get_pos().y, circumcenter);
								radiusSquared = ( ( (( vertexA.get_pos().x - circumcenter.x )) * (( vertexA.get_pos().x - circumcenter.x )) ) + ( (( vertexA.get_pos().y - circumcenter.y )) * (( vertexA.get_pos().y - circumcenter.y )) ) );
								radiusSquared -= 0.0001;
								{
									int _g2 = 2;
									int _g3 = bound.length;
									while (( _g2 < _g3 )) {
										int j = _g2++;
										if (( j != i1 )) {
											vertexCheck = ((global::hxDaedalus.data.Edge) (bound[j]) ).get_originVertex();
											distanceSquared = ( ( (( vertexCheck.get_pos().x - circumcenter.x )) * (( vertexCheck.get_pos().x - circumcenter.x )) ) + ( (( vertexCheck.get_pos().y - circumcenter.y )) * (( vertexCheck.get_pos().y - circumcenter.y )) ) );
											if (( distanceSquared < radiusSquared )) {
												isDelaunay = false;
												break;
											}
											
										}
										
									}
									
								}
								
								if (isDelaunay) {
									break;
								}
								
							}
							
						}
						
					}
					
					if ( ! (isDelaunay) ) {
						string s = "";
						{
							int _g4 = 0;
							int _g5 = bound.length;
							while (( _g4 < _g5 )) {
								int i2 = _g4++;
								s = global::haxe.lang.Runtime.concat(s, global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.toString(((global::hxDaedalus.data.Edge) (bound[i2]) ).get_originVertex().get_pos().x), " , "));
								s = global::haxe.lang.Runtime.concat(s, global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.toString(((global::hxDaedalus.data.Edge) (bound[i2]) ).get_originVertex().get_pos().y), " , "));
								s = global::haxe.lang.Runtime.concat(s, global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.toString(((global::hxDaedalus.data.Edge) (bound[i2]) ).get_destinationVertex().get_pos().x), " , "));
								s = global::haxe.lang.Runtime.concat(s, global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.toString(((global::hxDaedalus.data.Edge) (bound[i2]) ).get_destinationVertex().get_pos().y), " , "));
							}
							
						}
						
						index = 2;
					}
					
					global::hxDaedalus.data.Edge edgeA = null;
					global::hxDaedalus.data.Edge edgeAopp = null;
					global::hxDaedalus.data.Edge edgeB = null;
					global::hxDaedalus.data.Edge edgeBopp = null;
					global::HxArray<object> boundA = null;
					global::HxArray<object> boundM = null;
					global::HxArray<object> boundB = null;
					if (( index < ( bound.length - 1 ) )) {
						edgeA = new global::hxDaedalus.data.Edge();
						edgeAopp = new global::hxDaedalus.data.Edge();
						this._edges.push(edgeA);
						this._edges.push(edgeAopp);
						edgeA.setDatas(vertexA, edgeAopp, null, null, new global::haxe.lang.Null<bool>(isReal, true), new global::haxe.lang.Null<bool>(false, true));
						edgeAopp.setDatas(((global::hxDaedalus.data.Edge) (bound[index]) ).get_originVertex(), edgeA, null, null, new global::haxe.lang.Null<bool>(isReal, true), new global::haxe.lang.Null<bool>(false, true));
						boundA = bound.slice(index, default(global::haxe.lang.Null<int>));
						boundA.push(edgeA);
						this.triangulate(boundA, isReal);
					}
					
					if (( index > 2 )) {
						edgeB = new global::hxDaedalus.data.Edge();
						edgeBopp = new global::hxDaedalus.data.Edge();
						this._edges.push(edgeB);
						this._edges.push(edgeBopp);
						edgeB.setDatas(((global::hxDaedalus.data.Edge) (bound[1]) ).get_originVertex(), edgeBopp, null, null, new global::haxe.lang.Null<bool>(isReal, true), new global::haxe.lang.Null<bool>(false, true));
						edgeBopp.setDatas(((global::hxDaedalus.data.Edge) (bound[index]) ).get_originVertex(), edgeB, null, null, new global::haxe.lang.Null<bool>(isReal, true), new global::haxe.lang.Null<bool>(false, true));
						boundB = bound.slice(1, new global::haxe.lang.Null<int>(index, true));
						boundB.push(edgeBopp);
						this.triangulate(boundB, isReal);
					}
					
					if (( index == 2 )) {
						boundM = new global::HxArray<object>(new object[]{baseEdge, ((global::hxDaedalus.data.Edge) (bound[1]) ), edgeAopp});
					}
					else if (( index == ( bound.length - 1 ) )) {
						boundM = new global::HxArray<object>(new object[]{baseEdge, edgeB, ((global::hxDaedalus.data.Edge) (bound[index]) )});
					}
					else {
						boundM = new global::HxArray<object>(new object[]{baseEdge, edgeB, edgeAopp});
					}
					
					this.triangulate(boundM, isReal);
				}
				
			}
		}
		
		
		public virtual int findPositionFromBounds(double x, double y) {
			unchecked {
				if (( x <= 0 )) {
					if (( y <= 0 )) {
						return 1;
					}
					else if (( y >= this._height )) {
						return 7;
					}
					else {
						return 8;
					}
					
				}
				else if (( x >= this._width )) {
					if (( y <= 0 )) {
						return 3;
					}
					else if (( y >= this._height )) {
						return 5;
					}
					else {
						return 4;
					}
					
				}
				else if (( y <= 0 )) {
					return 2;
				}
				else if (( y >= this._height )) {
					return 6;
				}
				else {
					return 0;
				}
				
			}
		}
		
		
		public virtual void debug() {
			int i = default(int);
			{
				int _g = 0;
				int _g1 = this._vertices.length;
				while (( _g < _g1 )) {
					int i1 = _g++;
					object @value = ((object) (global::haxe.lang.Runtime.concat("-- vertex ", global::haxe.lang.Runtime.toString(((global::hxDaedalus.data.Vertex) (this._vertices[i1]) ).get_id()))) );
					object value1 = ((object) (global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("  edge ", global::haxe.lang.Runtime.toString(((global::hxDaedalus.data.Vertex) (this._vertices[i1]) ).get_edge().get_id())), " - "), global::HxStd.@string(((global::hxDaedalus.data.Vertex) (this._vertices[i1]) ).get_edge()))) );
					object value2 = ((object) (global::haxe.lang.Runtime.concat("  edge isReal: ", global::HxStd.@string(((global::hxDaedalus.data.Vertex) (this._vertices[i1]) ).get_edge().get_isReal()))) );
				}
				
			}
			
			{
				int _g2 = 0;
				int _g3 = this._edges.length;
				while (( _g2 < _g3 )) {
					int i2 = _g2++;
					object value3 = ((object) (global::haxe.lang.Runtime.concat("-- edge ", global::HxStd.@string(((global::hxDaedalus.data.Edge) (this._edges[i2]) )))) );
					object value4 = ((object) (global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("  isReal ", global::haxe.lang.Runtime.toString(((global::hxDaedalus.data.Edge) (this._edges[i2]) ).get_id())), " - "), global::HxStd.@string(((global::hxDaedalus.data.Edge) (this._edges[i2]) ).get_isReal()))) );
					object value5 = ((object) (global::haxe.lang.Runtime.concat("  nextLeftEdge ", global::HxStd.@string(((global::hxDaedalus.data.Edge) (this._edges[i2]) ).get_nextLeftEdge()))) );
					object value6 = ((object) (global::haxe.lang.Runtime.concat("  oppositeEdge ", global::HxStd.@string(((global::hxDaedalus.data.Edge) (this._edges[i2]) ).get_oppositeEdge()))) );
				}
				
			}
			
		}
		
		
		public virtual object getVerticesAndEdges() {
			object res = new global::haxe.lang.DynamicObject(new int[]{1776315798, 1779810297}, new object[]{new global::HxArray<object>(new object[]{}), new global::HxArray<object>(new object[]{})}, new int[]{}, new double[]{});
			global::hxDaedalus.data.Vertex vertex = null;
			global::hxDaedalus.data.Edge incomingEdge = null;
			global::hxDaedalus.data.Face holdingFace = null;
			global::hxDaedalus.iterators.FromMeshToVertices iterVertices = new global::hxDaedalus.iterators.FromMeshToVertices();
			iterVertices.set_fromMesh(this);
			global::hxDaedalus.iterators.FromVertexToIncomingEdges iterEdges = new global::hxDaedalus.iterators.FromVertexToIncomingEdges();
			global::haxe.ds.ObjectMap<object, bool> dictVerticesDone = new global::haxe.ds.ObjectMap<object, bool>();
			while (true) {
				vertex = iterVertices.next();
				if ( ! ((( vertex != null ))) ) {
					break;
				}
				
				dictVerticesDone.@set(vertex, true);
				if (( ( ( ( vertex.get_pos().x < 0 ) || ( vertex.get_pos().x > this.get_width() ) ) || ( vertex.get_pos().y < 0 ) ) || ( vertex.get_pos().y > this.get_height() ) )) {
					continue;
				}
				
				((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (global::haxe.lang.Runtime.getField(res, "vertices", 1779810297, true)) ))) ).push(vertex);
				iterEdges.set_fromVertex(vertex);
				while (true) {
					incomingEdge = iterEdges.next();
					if ( ! ((( incomingEdge != null ))) ) {
						break;
					}
					
					if (( ! ((dictVerticesDone.@get(incomingEdge.get_originVertex())).@value) )) {
						((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (global::haxe.lang.Runtime.getField(res, "edges", 1776315798, true)) ))) ).push(incomingEdge);
					}
					
				}
				
			}
			
			return res;
		}
		
		
		public bool vertexIsInsideAABB(global::hxDaedalus.data.Vertex vertex, global::hxDaedalus.data.Mesh mesh) {
			return  ! ((( ( ( ( vertex.get_pos().x < 0 ) || ( vertex.get_pos().x > mesh.get_width() ) ) || ( vertex.get_pos().y < 0 ) ) || ( vertex.get_pos().y > mesh.get_height() ) ))) ;
		}
		
		
		public override double __hx_setField_f(string field, int hash, double @value, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 1891834246:
					{
						this._height = ((double) (@value) );
						return @value;
					}
					
					
					case 1179254087:
					{
						this._width = ((double) (@value) );
						return @value;
					}
					
					
					case 4747770:
					{
						this._id = ((int) (@value) );
						return @value;
					}
					
					
					default:
					{
						return base.__hx_setField_f(field, hash, @value, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_setField(string field, int hash, object @value, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 1507396079:
					{
						this.__objectsUpdateInProgress = global::haxe.lang.Runtime.toBool(@value);
						return @value;
					}
					
					
					case 278045047:
					{
						this.__edgesToCheck = ((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (@value) ))) );
						return @value;
					}
					
					
					case 104695353:
					{
						this.__centerVertex = ((global::hxDaedalus.data.Vertex) (@value) );
						return @value;
					}
					
					
					case 1007141461:
					{
						this._objects = ((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (@value) ))) );
						return @value;
					}
					
					
					case 22110414:
					{
						this._constraintShapes = ((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (@value) ))) );
						return @value;
					}
					
					
					case 1999608951:
					{
						this._faces = ((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (@value) ))) );
						return @value;
					}
					
					
					case 1707586775:
					{
						this._edges = ((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (@value) ))) );
						return @value;
					}
					
					
					case 833337176:
					{
						this._vertices = ((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (@value) ))) );
						return @value;
					}
					
					
					case 869793953:
					{
						this._clipping = global::haxe.lang.Runtime.toBool(@value);
						return @value;
					}
					
					
					case 1891834246:
					{
						this._height = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					case 1179254087:
					{
						this._width = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					case 4747770:
					{
						this._id = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 1816267074:
					{
						this.set_clipping(global::haxe.lang.Runtime.toBool(@value));
						return @value;
					}
					
					
					default:
					{
						return base.__hx_setField(field, hash, @value, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_getField(string field, int hash, bool throwErrors, bool isCheck, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 85274282:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "vertexIsInsideAABB", 85274282)) );
					}
					
					
					case 1747467534:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "getVerticesAndEdges", 1747467534)) );
					}
					
					
					case 1461670483:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "debug", 1461670483)) );
					}
					
					
					case 2143646753:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "findPositionFromBounds", 2143646753)) );
					}
					
					
					case 1771922732:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "triangulate", 1771922732)) );
					}
					
					
					case 181918579:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "untriangulate", 181918579)) );
					}
					
					
					case 132121071:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "deleteVertex", 132121071)) );
					}
					
					
					case 1818729159:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "restoreAsDelaunay", 1818729159)) );
					}
					
					
					case 1209352343:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "splitFace", 1209352343)) );
					}
					
					
					case 1198412855:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "splitEdge", 1198412855)) );
					}
					
					
					case 2070503818:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "flipEdge", 2070503818)) );
					}
					
					
					case 399852413:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "insertVertex", 399852413)) );
					}
					
					
					case 1169594568:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "check", 1169594568)) );
					}
					
					
					case 533040171:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "deleteConstraintSegment", 533040171)) );
					}
					
					
					case 359360716:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "insertNewConstrainedEdge", 359360716)) );
					}
					
					
					case 1827977565:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "insertConstraintSegment", 1827977565)) );
					}
					
					
					case 1020334489:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "deleteConstraintShape", 1020334489)) );
					}
					
					
					case 402271819:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "insertConstraintShape", 402271819)) );
					}
					
					
					case 1304284619:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "updateObjects", 1304284619)) );
					}
					
					
					case 1507396079:
					{
						return this.__objectsUpdateInProgress;
					}
					
					
					case 2077730122:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "deleteObject", 2077730122)) );
					}
					
					
					case 197977816:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "insertObject", 197977816)) );
					}
					
					
					case 1761828969:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "buildFromRecord", 1761828969)) );
					}
					
					
					case 771456728:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "get___constraintShapes", 771456728)) );
					}
					
					
					case 994869407:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "dispose", 994869407)) );
					}
					
					
					case 590344996:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "get_id", 590344996)) );
					}
					
					
					case 911532223:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "set_clipping", 911532223)) );
					}
					
					
					case 559660363:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "get_clipping", 559660363)) );
					}
					
					
					case 235672157:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "get_width", 235672157)) );
					}
					
					
					case 1926461360:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "get_height", 1926461360)) );
					}
					
					
					case 278045047:
					{
						return this.__edgesToCheck;
					}
					
					
					case 104695353:
					{
						return this.__centerVertex;
					}
					
					
					case 1007141461:
					{
						return this._objects;
					}
					
					
					case 22110414:
					{
						return this._constraintShapes;
					}
					
					
					case 1999608951:
					{
						return this._faces;
					}
					
					
					case 1707586775:
					{
						return this._edges;
					}
					
					
					case 833337176:
					{
						return this._vertices;
					}
					
					
					case 869793953:
					{
						return this._clipping;
					}
					
					
					case 1891834246:
					{
						return this._height;
					}
					
					
					case 1179254087:
					{
						return this._width;
					}
					
					
					case 4747770:
					{
						return this._id;
					}
					
					
					case 1416037775:
					{
						return this.get___constraintShapes();
					}
					
					
					case 23515:
					{
						return this.get_id();
					}
					
					
					case 1816267074:
					{
						return this.get_clipping();
					}
					
					
					case 1247983110:
					{
						return this.get_width();
					}
					
					
					case 38537191:
					{
						return this.get_height();
					}
					
					
					default:
					{
						return base.__hx_getField(field, hash, throwErrors, isCheck, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override double __hx_getField_f(string field, int hash, bool throwErrors, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 1891834246:
					{
						return this._height;
					}
					
					
					case 1179254087:
					{
						return this._width;
					}
					
					
					case 4747770:
					{
						return ((double) (this._id) );
					}
					
					
					case 23515:
					{
						return ((double) (this.get_id()) );
					}
					
					
					case 1247983110:
					{
						return this.get_width();
					}
					
					
					case 38537191:
					{
						return this.get_height();
					}
					
					
					default:
					{
						return base.__hx_getField_f(field, hash, throwErrors, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_invokeField(string field, int hash, object[] dynargs) {
			unchecked {
				switch (hash) {
					case 85274282:
					{
						return this.vertexIsInsideAABB(((global::hxDaedalus.data.Vertex) (dynargs[0]) ), ((global::hxDaedalus.data.Mesh) (dynargs[1]) ));
					}
					
					
					case 1747467534:
					{
						return this.getVerticesAndEdges();
					}
					
					
					case 1461670483:
					{
						this.debug();
						break;
					}
					
					
					case 2143646753:
					{
						return this.findPositionFromBounds(((double) (global::haxe.lang.Runtime.toDouble(dynargs[0])) ), ((double) (global::haxe.lang.Runtime.toDouble(dynargs[1])) ));
					}
					
					
					case 1771922732:
					{
						this.triangulate(((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (dynargs[0]) ))) ), global::haxe.lang.Runtime.toBool(dynargs[1]));
						break;
					}
					
					
					case 181918579:
					{
						this.untriangulate(((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (dynargs[0]) ))) ));
						break;
					}
					
					
					case 132121071:
					{
						return this.deleteVertex(((global::hxDaedalus.data.Vertex) (dynargs[0]) ));
					}
					
					
					case 1818729159:
					{
						this.restoreAsDelaunay();
						break;
					}
					
					
					case 1209352343:
					{
						return this.splitFace(((global::hxDaedalus.data.Face) (dynargs[0]) ), ((double) (global::haxe.lang.Runtime.toDouble(dynargs[1])) ), ((double) (global::haxe.lang.Runtime.toDouble(dynargs[2])) ));
					}
					
					
					case 1198412855:
					{
						return this.splitEdge(((global::hxDaedalus.data.Edge) (dynargs[0]) ), ((double) (global::haxe.lang.Runtime.toDouble(dynargs[1])) ), ((double) (global::haxe.lang.Runtime.toDouble(dynargs[2])) ));
					}
					
					
					case 2070503818:
					{
						return this.flipEdge(((global::hxDaedalus.data.Edge) (dynargs[0]) ));
					}
					
					
					case 399852413:
					{
						return this.insertVertex(((double) (global::haxe.lang.Runtime.toDouble(dynargs[0])) ), ((double) (global::haxe.lang.Runtime.toDouble(dynargs[1])) ));
					}
					
					
					case 1169594568:
					{
						this.check();
						break;
					}
					
					
					case 533040171:
					{
						this.deleteConstraintSegment(((global::hxDaedalus.data.ConstraintSegment) (dynargs[0]) ));
						break;
					}
					
					
					case 359360716:
					{
						this.insertNewConstrainedEdge(((global::hxDaedalus.data.ConstraintSegment) (dynargs[0]) ), ((global::hxDaedalus.data.Edge) (dynargs[1]) ), ((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (dynargs[2]) ))) ), ((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (dynargs[3]) ))) ), ((global::HxArray<object>) (global::HxArray<object>.__hx_cast<object>(((global::HxArray) (dynargs[4]) ))) ));
						break;
					}
					
					
					case 1827977565:
					{
						return this.insertConstraintSegment(((double) (global::haxe.lang.Runtime.toDouble(dynargs[0])) ), ((double) (global::haxe.lang.Runtime.toDouble(dynargs[1])) ), ((double) (global::haxe.lang.Runtime.toDouble(dynargs[2])) ), ((double) (global::haxe.lang.Runtime.toDouble(dynargs[3])) ));
					}
					
					
					case 1020334489:
					{
						this.deleteConstraintShape(((global::hxDaedalus.data.ConstraintShape) (dynargs[0]) ));
						break;
					}
					
					
					case 402271819:
					{
						return this.insertConstraintShape(((global::HxArray<double>) (global::HxArray<object>.__hx_cast<double>(((global::HxArray) (dynargs[0]) ))) ));
					}
					
					
					case 1304284619:
					{
						this.updateObjects();
						break;
					}
					
					
					case 2077730122:
					{
						this.deleteObject(((global::hxDaedalus.data.Object) (dynargs[0]) ));
						break;
					}
					
					
					case 197977816:
					{
						this.insertObject(((global::hxDaedalus.data.Object) (dynargs[0]) ));
						break;
					}
					
					
					case 1761828969:
					{
						this.buildFromRecord(global::haxe.lang.Runtime.toString(dynargs[0]));
						break;
					}
					
					
					case 771456728:
					{
						return this.get___constraintShapes();
					}
					
					
					case 994869407:
					{
						this.dispose();
						break;
					}
					
					
					case 590344996:
					{
						return this.get_id();
					}
					
					
					case 911532223:
					{
						return this.set_clipping(global::haxe.lang.Runtime.toBool(dynargs[0]));
					}
					
					
					case 559660363:
					{
						return this.get_clipping();
					}
					
					
					case 235672157:
					{
						return this.get_width();
					}
					
					
					case 1926461360:
					{
						return this.get_height();
					}
					
					
					default:
					{
						return base.__hx_invokeField(field, hash, dynargs);
					}
					
				}
				
				return null;
			}
		}
		
		
		public override void __hx_getFields(global::HxArray<string> baseArr) {
			baseArr.push("__objectsUpdateInProgress");
			baseArr.push("__edgesToCheck");
			baseArr.push("__centerVertex");
			baseArr.push("_objects");
			baseArr.push("_constraintShapes");
			baseArr.push("_faces");
			baseArr.push("_edges");
			baseArr.push("_vertices");
			baseArr.push("_clipping");
			baseArr.push("_height");
			baseArr.push("_width");
			baseArr.push("_id");
			baseArr.push("__constraintShapes");
			baseArr.push("id");
			baseArr.push("clipping");
			baseArr.push("width");
			baseArr.push("height");
			base.__hx_getFields(baseArr);
		}
		
		
	}
}


