// Generated by Haxe 4.3.6

#pragma warning disable 109, 114, 219, 429, 168, 162

using Pathfinding.Util;

namespace hxDaedalus.data.math {
	public class Intersection : global::haxe.lang.Enum {
		
		protected Intersection(int index) : base(index) {
		}
		
		
		public static global::hxDaedalus.data.math.Intersection EVertex(global::hxDaedalus.data.Vertex vertex) {
			return new global::hxDaedalus.data.math.Intersection_EVertex(vertex);
		}
		
		
		public static global::hxDaedalus.data.math.Intersection EEdge(global::hxDaedalus.data.Edge edge) {
			return new global::hxDaedalus.data.math.Intersection_EEdge(edge);
		}
		
		
		public static global::hxDaedalus.data.math.Intersection EFace(global::hxDaedalus.data.Face face) {
			return new global::hxDaedalus.data.math.Intersection_EFace(face);
		}
		
		
		public static readonly global::hxDaedalus.data.math.Intersection ENull = new global::hxDaedalus.data.math.Intersection_ENull();
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace hxDaedalus.data.math {
	public sealed class Intersection_EVertex : global::hxDaedalus.data.math.Intersection {
		
		public Intersection_EVertex(global::hxDaedalus.data.Vertex vertex) : base(0) {
			this.vertex = vertex;
		}
		
		
		public override global::HxArray<object> getParams() {
			return new global::HxArray<object>(new object[]{this.vertex});
		}
		
		
		public override string getTag() {
			return "EVertex";
		}
		
		
		public override int GetHashCode() {
			return global::haxe.lang.Enum.paramsGetHashCode(0, new object[]{this.vertex});
		}
		
		
		public override bool Equals(object other) {
			if (global::System.Object.ReferenceEquals(((object) (this) ), ((object) (other) ))) {
				return true;
			}
			
			global::hxDaedalus.data.math.Intersection_EVertex en = ( other as global::hxDaedalus.data.math.Intersection_EVertex );
			if (( en == null )) {
				return false;
			}
			
			if ( ! (global::HxType.enumEq<object>(((object) (this.vertex) ), ((object) (en.vertex) ))) ) {
				return false;
			}
			
			return true;
		}
		
		
		public override string toString() {
			return global::haxe.lang.Enum.paramsToString("EVertex", new object[]{this.vertex});
		}
		
		
		public readonly global::hxDaedalus.data.Vertex vertex;
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace hxDaedalus.data.math {
	public sealed class Intersection_EEdge : global::hxDaedalus.data.math.Intersection {
		
		public Intersection_EEdge(global::hxDaedalus.data.Edge edge) : base(1) {
			this.edge = edge;
		}
		
		
		public override global::HxArray<object> getParams() {
			return new global::HxArray<object>(new object[]{this.edge});
		}
		
		
		public override string getTag() {
			return "EEdge";
		}
		
		
		public override int GetHashCode() {
			unchecked {
				return global::haxe.lang.Enum.paramsGetHashCode(1, new object[]{this.edge});
			}
		}
		
		
		public override bool Equals(object other) {
			if (global::System.Object.ReferenceEquals(((object) (this) ), ((object) (other) ))) {
				return true;
			}
			
			global::hxDaedalus.data.math.Intersection_EEdge en = ( other as global::hxDaedalus.data.math.Intersection_EEdge );
			if (( en == null )) {
				return false;
			}
			
			if ( ! (global::HxType.enumEq<object>(((object) (this.edge) ), ((object) (en.edge) ))) ) {
				return false;
			}
			
			return true;
		}
		
		
		public override string toString() {
			return global::haxe.lang.Enum.paramsToString("EEdge", new object[]{this.edge});
		}
		
		
		public readonly global::hxDaedalus.data.Edge edge;
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace hxDaedalus.data.math {
	public sealed class Intersection_EFace : global::hxDaedalus.data.math.Intersection {
		
		public Intersection_EFace(global::hxDaedalus.data.Face face) : base(2) {
			this.face = face;
		}
		
		
		public override global::HxArray<object> getParams() {
			return new global::HxArray<object>(new object[]{this.face});
		}
		
		
		public override string getTag() {
			return "EFace";
		}
		
		
		public override int GetHashCode() {
			unchecked {
				return global::haxe.lang.Enum.paramsGetHashCode(2, new object[]{this.face});
			}
		}
		
		
		public override bool Equals(object other) {
			if (global::System.Object.ReferenceEquals(((object) (this) ), ((object) (other) ))) {
				return true;
			}
			
			global::hxDaedalus.data.math.Intersection_EFace en = ( other as global::hxDaedalus.data.math.Intersection_EFace );
			if (( en == null )) {
				return false;
			}
			
			if ( ! (global::HxType.enumEq<object>(((object) (this.face) ), ((object) (en.face) ))) ) {
				return false;
			}
			
			return true;
		}
		
		
		public override string toString() {
			return global::haxe.lang.Enum.paramsToString("EFace", new object[]{this.face});
		}
		
		
		public readonly global::hxDaedalus.data.Face face;
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace hxDaedalus.data.math {
	public sealed class Intersection_ENull : global::hxDaedalus.data.math.Intersection {
		
		public Intersection_ENull() : base(3) {
		}
		
		
		public override string getTag() {
			return "ENull";
		}
		
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace hxDaedalus.data.math {
	public class Geom2D : global::haxe.lang.HxObject {
		
		static Geom2D() {
			global::hxDaedalus.data.math.Geom2D.__samples = new global::HxArray<object>();
			global::hxDaedalus.data.math.Geom2D.__circumcenter = new global::hxDaedalus.data.math.Point2D(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
		}
		
		
		public Geom2D(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public Geom2D() {
			global::hxDaedalus.data.math.Geom2D.__hx_ctor_hxDaedalus_data_math_Geom2D(this);
		}
		
		
		protected static void __hx_ctor_hxDaedalus_data_math_Geom2D(global::hxDaedalus.data.math.Geom2D __hx_this) {
		}
		
		
		public static global::hxDaedalus.data.math.RandGenerator _randGen;
		
		public static global::HxArray<object> __samples;
		
		public static global::hxDaedalus.data.math.Intersection locatePosition(double x, double y, global::hxDaedalus.data.Mesh mesh) {
			unchecked {
				if (( global::hxDaedalus.data.math.Geom2D._randGen == null )) {
					global::hxDaedalus.data.math.Geom2D._randGen = new global::hxDaedalus.data.math.RandGenerator(default(global::haxe.lang.Null<int>), default(global::haxe.lang.Null<int>), default(global::haxe.lang.Null<int>));
				}
				
				global::hxDaedalus.data.math.Geom2D._randGen.set_seed(((int) (( ( x * 10 ) + ( 4 * y ) )) ));
				int i = default(int);
				global::hxDaedalus.data.math.Geom2D.__samples.spliceVoid(0, global::hxDaedalus.data.math.Geom2D.__samples.length);
				int numSamples = ((int) (global::System.Math.Pow(((double) (mesh._vertices.length) ), ((double) (0.33333333333333331) ))) );
				global::hxDaedalus.data.math.Geom2D._randGen.rangeMin = 0;
				global::hxDaedalus.data.math.Geom2D._randGen.rangeMax = ( mesh._vertices.length - 1 );
                // Debug.LogToFile($"locatePosition ({x}, {y}) numSamples:{numSamples} _vertices.Count:{mesh._vertices.length}");
                {
                    int _g = 0;
					int _g1 = numSamples;
					while (( _g < _g1 )) {
						int i1 = _g++;
						int _rnd = global::hxDaedalus.data.math.Geom2D._randGen.next();
						global::hxDaedalus.data.math.Geom2D.__samples.push(((global::hxDaedalus.data.Vertex) (mesh._vertices[_rnd]) ));
					}
					
				}
				
				global::hxDaedalus.data.Vertex currVertex = null;
				global::hxDaedalus.data.math.Point2D currVertexPos = null;
				double distSquared = default(double);
				double minDistSquared = global::HxMath.POSITIVE_INFINITY;
				global::hxDaedalus.data.Vertex closedVertex = null;
				{
					int _g2 = 0;
					int _g3 = numSamples;
					while (( _g2 < _g3 )) {
						int i2 = _g2++;
						currVertex = ((global::hxDaedalus.data.Vertex) (global::hxDaedalus.data.math.Geom2D.__samples[i2]) );
						currVertexPos = currVertex.get_pos();
						distSquared = ( ( (( currVertexPos.x - x )) * (( currVertexPos.x - x )) ) + ( (( currVertexPos.y - y )) * (( currVertexPos.y - y )) ) );
						if (( distSquared < minDistSquared )) {
							minDistSquared = distSquared;
							closedVertex = currVertex;
						}
						
					}
					
				}
				
				global::hxDaedalus.iterators.FromVertexToHoldingFaces iterFace = new global::hxDaedalus.iterators.FromVertexToHoldingFaces();
				iterFace.set_fromVertex(closedVertex);
				global::hxDaedalus.data.Face currFace = iterFace.next();
				global::haxe.ds.ObjectMap<object, bool> faceVisited = new global::haxe.ds.ObjectMap<object, bool>();
				global::hxDaedalus.data.Edge currEdge = null;
				global::hxDaedalus.iterators.FromFaceToInnerEdges iterEdge = new global::hxDaedalus.iterators.FromFaceToInnerEdges();
				global::hxDaedalus.data.math.Intersection objectContainer = global::hxDaedalus.data.math.Intersection.ENull;
				int relativPos = default(int);
				int numIter = 0;
				while (true) {
                    // Debug.LogToFile($"locatePosition LOOP currFace:{currFace._id}");
                    if (currFace._id == 26)
                    {
                        int stop = 0;
                    }
                    bool tmp = default(bool);
					if (( ! ((faceVisited.@get(currFace)).@value) )) {
						objectContainer = global::hxDaedalus.data.math.Geom2D.isInFace(x, y, currFace);
						tmp = ( objectContainer._hx_index == 3 );
					}
					else {
						tmp = true;
					}
					
					if ( ! (tmp) ) {
                        Debug.LogToFile($"locatePosition LOOP SUCESS");
                        break;
					}
					
					faceVisited.@get(currFace);
					 ++ numIter;
					bool tmp1 = ( numIter == 50 );
					iterEdge.set_fromFace(currFace);
					do {
						currEdge = iterEdge.next();
						if (( currEdge == null )) {
							return global::hxDaedalus.data.math.Intersection.ENull;
						}

                        // Debug.LogToFile($"locatePosition LOOP currFace:{currFace._id} currEdge:{currEdge._id}");
                        relativPos = global::hxDaedalus.data.math.Geom2D.getRelativePosition(x, y, currEdge);
					}
					while (( ( relativPos == 1 ) || ( relativPos == 0 ) ));
					currFace = currEdge.get_rightFace();
				}
				
				return objectContainer;
			}
		}
		
		
		public static bool isCircleIntersectingAnyConstraint(double x, double y, double radius, global::hxDaedalus.data.Mesh mesh) {
			unchecked {
				if (( ( ( ( x <= 0 ) || ( x >= mesh.get_width() ) ) || ( y <= 0 ) ) || ( y >= mesh.get_height() ) )) {
					return true;
				}
				
				global::hxDaedalus.data.math.Intersection loc = global::hxDaedalus.data.math.Geom2D.locatePosition(x, y, mesh);
				global::hxDaedalus.data.Face face = null;
				switch (loc._hx_index) {
					case 0:
					{
						global::hxDaedalus.data.Vertex vertex = ( loc as global::hxDaedalus.data.math.Intersection_EVertex ).vertex;
						face = vertex.get_edge().get_leftFace();
						break;
					}
					
					
					case 1:
					{
						global::hxDaedalus.data.Edge edge = ( loc as global::hxDaedalus.data.math.Intersection_EEdge ).edge;
						face = edge.get_leftFace();
						break;
					}
					
					
					case 2:
					{
						global::hxDaedalus.data.Face face_ = ( loc as global::hxDaedalus.data.math.Intersection_EFace ).face;
						face = face_;
						break;
					}
					
					
					case 3:
					{
						face = null;
						break;
					}
					
					
				}
				
				double radiusSquared = ( radius * radius );
				global::hxDaedalus.data.math.Point2D pos = face.get_edge().get_originVertex().get_pos();
				double distSquared = ( ( (( pos.x - x )) * (( pos.x - x )) ) + ( (( pos.y - y )) * (( pos.y - y )) ) );
				if (( distSquared <= radiusSquared )) {
					return true;
				}
				
				pos = face.get_edge().get_nextLeftEdge().get_originVertex().get_pos();
				distSquared = ( ( (( pos.x - x )) * (( pos.x - x )) ) + ( (( pos.y - y )) * (( pos.y - y )) ) );
				if (( distSquared <= radiusSquared )) {
					return true;
				}
				
				pos = face.get_edge().get_nextLeftEdge().get_nextLeftEdge().get_originVertex().get_pos();
				distSquared = ( ( (( pos.x - x )) * (( pos.x - x )) ) + ( (( pos.y - y )) * (( pos.y - y )) ) );
				if (( distSquared <= radiusSquared )) {
					return true;
				}
				
				global::HxArray<object> edgesToCheck = new global::HxArray<object>();
				edgesToCheck.push(face.get_edge());
				edgesToCheck.push(face.get_edge().get_nextLeftEdge());
				edgesToCheck.push(face.get_edge().get_nextLeftEdge().get_nextLeftEdge());
				global::hxDaedalus.data.Edge edge1 = null;
				global::hxDaedalus.data.math.Point2D pos1 = null;
				global::hxDaedalus.data.math.Point2D pos2 = null;
				global::haxe.ds.ObjectMap<object, bool> checkedEdges = new global::haxe.ds.ObjectMap<object, bool>();
				bool intersecting = default(bool);
				while (( edgesToCheck.length > 0 )) {
					edge1 = ((global::hxDaedalus.data.Edge) ((edgesToCheck.pop()).@value) );
					checkedEdges.@set(edge1, true);
					pos1 = edge1.get_originVertex().get_pos();
					pos2 = edge1.get_destinationVertex().get_pos();
					intersecting = global::hxDaedalus.data.math.Geom2D.intersectionsSegmentCircle(pos1.x, pos1.y, pos2.x, pos2.y, x, y, radius, null);
					if (intersecting) {
						if (edge1.get_isConstrained()) {
							return true;
						}
						else {
							edge1 = edge1.get_oppositeEdge().get_nextLeftEdge();
							if (( ( ( ( ! ((checkedEdges.@get(edge1)).@value) ) && ( ! ((checkedEdges.@get(edge1.get_oppositeEdge())).@value) ) ) && ( edgesToCheck.indexOf(edge1, default(global::haxe.lang.Null<int>)) == -1 ) ) && ( edgesToCheck.indexOf(edge1.get_oppositeEdge(), default(global::haxe.lang.Null<int>)) == -1 ) )) {
								edgesToCheck.push(edge1);
							}
							
							edge1 = edge1.get_nextLeftEdge();
							if (( ( ( ( ! ((checkedEdges.@get(edge1)).@value) ) && ( ! ((checkedEdges.@get(edge1.get_oppositeEdge())).@value) ) ) && ( edgesToCheck.indexOf(edge1, default(global::haxe.lang.Null<int>)) == -1 ) ) && ( edgesToCheck.indexOf(edge1.get_oppositeEdge(), default(global::haxe.lang.Null<int>)) == -1 ) )) {
								edgesToCheck.push(edge1);
							}
							
						}
						
					}
					
				}
				
				return false;
			}
		}
		
		
		public static int getDirection(double x1, double y1, double x2, double y2, double x3, double y3) {
			unchecked {
                var a = x3 - x1;
                var b = y3 - y1;
                var c = -x2 + x1;
                var d = y2 - y1;
                var dot = a * d + b * c;
                // double dot = ( ( (( x3 - x1 )) * (( y2 - y1 )) ) + ( (( y3 - y1 )) * ((  - (x2)  + x1 )) ) );
				if (( dot == 0 )) {
					return 0;
				}
				else if (( dot > 0 )) {
					return 1;
				}
				else {
					return -1;
				}
				
			}
		}
		
		
		public static int getDirection2(double x1, double y1, double x2, double y2, double x3, double y3) {
			unchecked {
				double dot = ( ( (( x3 - x1 )) * (( y2 - y1 )) ) + ( (( y3 - y1 )) * ((  - (x2)  + x1 )) ) );
				if (( dot == 0 )) {
					return 0;
				}
				else if (( dot > 0 )) {
					if (( global::hxDaedalus.data.math.Geom2D.distanceSquaredPointToLine(x3, y3, x1, y1, x2, y2) <= 0.0001 )) {
						return 0;
					}
					else {
						return 1;
					}
					
				}
				else if (( global::hxDaedalus.data.math.Geom2D.distanceSquaredPointToLine(x3, y3, x1, y1, x2, y2) <= 0.0001 )) {
					return 0;
				}
				else {
					return -1;
				}
				
			}
		}
		
		
		public static int getRelativePosition(double x, double y, global::hxDaedalus.data.Edge eUp) {
			return global::hxDaedalus.data.math.Geom2D.getDirection(eUp.get_originVertex().get_pos().x, eUp.get_originVertex().get_pos().y, eUp.get_destinationVertex().get_pos().x, eUp.get_destinationVertex().get_pos().y, x, y);
		}
		
		
		public static int getRelativePosition2(double x, double y, global::hxDaedalus.data.Edge eUp) {
			return global::hxDaedalus.data.math.Geom2D.getDirection2(eUp.get_originVertex().get_pos().x, eUp.get_originVertex().get_pos().y, eUp.get_destinationVertex().get_pos().x, eUp.get_destinationVertex().get_pos().y, x, y);
		}
		
		
		public static global::hxDaedalus.data.math.Intersection isInFace(double x, double y, global::hxDaedalus.data.Face polygon) {
			global::hxDaedalus.data.math.Intersection result = global::hxDaedalus.data.math.Intersection.ENull;
			global::hxDaedalus.data.Edge e1_2 = polygon.get_edge();
			global::hxDaedalus.data.Edge e2_3 = e1_2.get_nextLeftEdge();
			global::hxDaedalus.data.Edge e3_1 = e2_3.get_nextLeftEdge();
            // Debug.LogToFile($"pos: ({x}, {y})");
            // Debug.LogToFile($"e1_2:{e1_2._id} s:{e1_2.get_originVertex().get_pos().toString()}, e:{e1_2.get_destinationVertex().get_pos().toString()}");
            // Debug.LogToFile($"e2_3:{e2_3._id} s:{e2_3.get_originVertex().get_pos().toString()}, e:{e2_3.get_destinationVertex().get_pos().toString()}");
            // Debug.LogToFile($"e3_1:{e3_1._id} s:{e3_1.get_originVertex().get_pos().toString()}, e:{e3_1.get_destinationVertex().get_pos().toString()}");
            // Debug.LogToFile($"isInFace, e1_2:{getRelativePosition(x, y, e1_2)}, e2_3:{getRelativePosition(x, y, e2_3)}, e3_1:{getRelativePosition(x, y, e3_1)}");
            if (( ( ( global::hxDaedalus.data.math.Geom2D.getRelativePosition(x, y, e1_2) >= 0 ) && ( global::hxDaedalus.data.math.Geom2D.getRelativePosition(x, y, e2_3) >= 0 ) ) && ( global::hxDaedalus.data.math.Geom2D.getRelativePosition(x, y, e3_1) >= 0 ) )) {
				global::hxDaedalus.data.Vertex v1 = e1_2.get_originVertex();
				global::hxDaedalus.data.Vertex v2 = e2_3.get_originVertex();
				global::hxDaedalus.data.Vertex v3 = e3_1.get_originVertex();
				double x1 = v1.get_pos().x;
				double y1 = v1.get_pos().y;
				double x2 = v2.get_pos().x;
				double y2 = v2.get_pos().y;
				double x3 = v3.get_pos().x;
				double y3 = v3.get_pos().y;
				double v_v1squaredLength = ( ( (( x1 - x )) * (( x1 - x )) ) + ( (( y1 - y )) * (( y1 - y )) ) );
				double v_v2squaredLength = ( ( (( x2 - x )) * (( x2 - x )) ) + ( (( y2 - y )) * (( y2 - y )) ) );
				double v_v3squaredLength = ( ( (( x3 - x )) * (( x3 - x )) ) + ( (( y3 - y )) * (( y3 - y )) ) );
				double v1_v2squaredLength = ( ( (( x2 - x1 )) * (( x2 - x1 )) ) + ( (( y2 - y1 )) * (( y2 - y1 )) ) );
				double v2_v3squaredLength = ( ( (( x3 - x2 )) * (( x3 - x2 )) ) + ( (( y3 - y2 )) * (( y3 - y2 )) ) );
				double v3_v1squaredLength = ( ( (( x1 - x3 )) * (( x1 - x3 )) ) + ( (( y1 - y3 )) * (( y1 - y3 )) ) );
				double dot_v_v1v2 = ( ( (( x - x1 )) * (( x2 - x1 )) ) + ( (( y - y1 )) * (( y2 - y1 )) ) );
				double dot_v_v2v3 = ( ( (( x - x2 )) * (( x3 - x2 )) ) + ( (( y - y2 )) * (( y3 - y2 )) ) );
				double dot_v_v3v1 = ( ( (( x - x3 )) * (( x1 - x3 )) ) + ( (( y - y3 )) * (( y1 - y3 )) ) );
				double v_e1_2squaredLength = ( v_v1squaredLength - ( ( dot_v_v1v2 * dot_v_v1v2 ) / v1_v2squaredLength ) );
				double v_e2_3squaredLength = ( v_v2squaredLength - ( ( dot_v_v2v3 * dot_v_v2v3 ) / v2_v3squaredLength ) );
				double v_e3_1squaredLength = ( v_v3squaredLength - ( ( dot_v_v3v1 * dot_v_v3v1 ) / v3_v1squaredLength ) );
				bool closeTo_e1_2 = ( v_e1_2squaredLength <= 0.0001 );
				bool closeTo_e2_3 = ( v_e2_3squaredLength <= 0.0001 );
				bool closeTo_e3_1 = ( v_e3_1squaredLength <= 0.0001 );
				if (closeTo_e1_2) {
					if (closeTo_e3_1) {
						result = global::hxDaedalus.data.math.Intersection.EVertex(v1);
					}
					else if (closeTo_e2_3) {
						result = global::hxDaedalus.data.math.Intersection.EVertex(v2);
					}
					else {
						result = global::hxDaedalus.data.math.Intersection.EEdge(e1_2);
					}
					
				}
				else if (closeTo_e2_3) {
					if (closeTo_e3_1) {
						result = global::hxDaedalus.data.math.Intersection.EVertex(v3);
					}
					else {
						result = global::hxDaedalus.data.math.Intersection.EEdge(e2_3);
					}
					
				}
				else if (closeTo_e3_1) {
					result = global::hxDaedalus.data.math.Intersection.EEdge(e3_1);
				}
				else {
					result = global::hxDaedalus.data.math.Intersection.EFace(polygon);
				}
				
			}
			
			return result;
		}
		
		
		public static bool clipSegmentByTriangle(double s1x, double s1y, double s2x, double s2y, double t1x, double t1y, double t2x, double t2y, double t3x, double t3y, global::hxDaedalus.data.math.Point2D pResult1, global::hxDaedalus.data.math.Point2D pResult2) {
			unchecked {
				int side1_1 = global::hxDaedalus.data.math.Geom2D.getDirection(t1x, t1y, t2x, t2y, s1x, s1y);
				int side1_2 = global::hxDaedalus.data.math.Geom2D.getDirection(t1x, t1y, t2x, t2y, s2x, s2y);
				if (( ( side1_1 <= 0 ) && ( side1_2 <= 0 ) )) {
					return false;
				}
				
				int side2_1 = global::hxDaedalus.data.math.Geom2D.getDirection(t2x, t2y, t3x, t3y, s1x, s1y);
				int side2_2 = global::hxDaedalus.data.math.Geom2D.getDirection(t2x, t2y, t3x, t3y, s2x, s2y);
				if (( ( side2_1 <= 0 ) && ( side2_2 <= 0 ) )) {
					return false;
				}
				
				int side3_1 = global::hxDaedalus.data.math.Geom2D.getDirection(t3x, t3y, t1x, t1y, s1x, s1y);
				int side3_2 = global::hxDaedalus.data.math.Geom2D.getDirection(t3x, t3y, t1x, t1y, s2x, s2y);
				if (( ( side3_1 <= 0 ) && ( side3_2 <= 0 ) )) {
					return false;
				}
				
				if (( ( ( ( side1_1 >= 0 ) && ( side2_1 >= 0 ) ) && ( side3_1 >= 0 ) ) && (( ( ( side1_2 >= 0 ) && ( side2_2 >= 0 ) ) && ( side3_2 >= 0 ) )) )) {
					pResult1.x = s1x;
					pResult1.y = s1y;
					pResult2.x = s2x;
					pResult2.y = s2y;
					return true;
				}
				
				int n = 0;
				if (global::hxDaedalus.data.math.Geom2D.intersections2segments(s1x, s1y, s2x, s2y, t1x, t1y, t2x, t2y, pResult1, null, default(global::haxe.lang.Null<bool>))) {
					 ++ n;
				}
				
				if (( n == 0 )) {
					if (global::hxDaedalus.data.math.Geom2D.intersections2segments(s1x, s1y, s2x, s2y, t2x, t2y, t3x, t3y, pResult1, null, default(global::haxe.lang.Null<bool>))) {
						 ++ n;
					}
					
				}
				else if (global::hxDaedalus.data.math.Geom2D.intersections2segments(s1x, s1y, s2x, s2y, t2x, t2y, t3x, t3y, pResult2, null, default(global::haxe.lang.Null<bool>))) {
					if (( ( ( ( -0.01 > ( pResult1.x - pResult2.x ) ) || ( ( pResult1.x - pResult2.x ) > 0.01 ) ) || ( -0.01 > ( pResult1.y - pResult2.y ) ) ) || ( ( pResult1.y - pResult2.y ) > 0.01 ) )) {
						 ++ n;
					}
					
				}
				
				if (( n == 0 )) {
					if (global::hxDaedalus.data.math.Geom2D.intersections2segments(s1x, s1y, s2x, s2y, t3x, t3y, t1x, t1y, pResult1, null, default(global::haxe.lang.Null<bool>))) {
						 ++ n;
					}
					
				}
				else if (( n == 1 )) {
					if (global::hxDaedalus.data.math.Geom2D.intersections2segments(s1x, s1y, s2x, s2y, t3x, t3y, t1x, t1y, pResult2, null, default(global::haxe.lang.Null<bool>))) {
						if (( ( ( ( -0.01 > ( pResult1.x - pResult2.x ) ) || ( ( pResult1.x - pResult2.x ) > 0.01 ) ) || ( -0.01 > ( pResult1.y - pResult2.y ) ) ) || ( ( pResult1.y - pResult2.y ) > 0.01 ) )) {
							 ++ n;
						}
						
					}
					
				}
				
				if (( n == 1 )) {
					if (( ( ( side1_1 >= 0 ) && ( side2_1 >= 0 ) ) && ( side3_1 >= 0 ) )) {
						pResult2.x = s1x;
						pResult2.y = s1y;
					}
					else if (( ( ( side1_2 >= 0 ) && ( side2_2 >= 0 ) ) && ( side3_2 >= 0 ) )) {
						pResult2.x = s2x;
						pResult2.y = s2y;
					}
					else {
						n = 0;
					}
					
				}
				
				if (( n > 0 )) {
					return true;
				}
				else {
					return false;
				}
				
			}
		}
		
		
		public static bool isSegmentIntersectingTriangle(double s1x, double s1y, double s2x, double s2y, double t1x, double t1y, double t2x, double t2y, double t3x, double t3y) {
			unchecked {
				int side1_1 = global::hxDaedalus.data.math.Geom2D.getDirection(t1x, t1y, t2x, t2y, s1x, s1y);
				int side1_2 = global::hxDaedalus.data.math.Geom2D.getDirection(t1x, t1y, t2x, t2y, s2x, s2y);
				if (( ( side1_1 <= 0 ) && ( side1_2 <= 0 ) )) {
					return false;
				}
				
				int side2_1 = global::hxDaedalus.data.math.Geom2D.getDirection(t2x, t2y, t3x, t3y, s1x, s1y);
				int side2_2 = global::hxDaedalus.data.math.Geom2D.getDirection(t2x, t2y, t3x, t3y, s2x, s2y);
				if (( ( side2_1 <= 0 ) && ( side2_2 <= 0 ) )) {
					return false;
				}
				
				int side3_1 = global::hxDaedalus.data.math.Geom2D.getDirection(t3x, t3y, t1x, t1y, s1x, s1y);
				int side3_2 = global::hxDaedalus.data.math.Geom2D.getDirection(t3x, t3y, t1x, t1y, s2x, s2y);
				if (( ( side3_1 <= 0 ) && ( side3_2 <= 0 ) )) {
					return false;
				}
				
				if (( ( ( side1_1 == 1 ) && ( side2_1 == 1 ) ) && ( side3_1 == 1 ) )) {
					return true;
				}
				
				if (( ( ( side1_1 == 1 ) && ( side2_1 == 1 ) ) && ( side3_1 == 1 ) )) {
					return true;
				}
				
				int side1 = default(int);
				int side2 = default(int);
				if (( ( ( side1_1 == 1 ) && ( side1_2 <= 0 ) ) || ( ( side1_1 <= 0 ) && ( side1_2 == 1 ) ) )) {
					side1 = global::hxDaedalus.data.math.Geom2D.getDirection(s1x, s1y, s2x, s2y, t1x, t1y);
					side2 = global::hxDaedalus.data.math.Geom2D.getDirection(s1x, s1y, s2x, s2y, t2x, t2y);
					if (( ( ( side1 == 1 ) && ( side2 <= 0 ) ) || ( ( side1 <= 0 ) && ( side2 == 1 ) ) )) {
						return true;
					}
					
				}
				
				if (( ( ( side2_1 == 1 ) && ( side2_2 <= 0 ) ) || ( ( side2_1 <= 0 ) && ( side2_2 == 1 ) ) )) {
					side1 = global::hxDaedalus.data.math.Geom2D.getDirection(s1x, s1y, s2x, s2y, t2x, t2y);
					side2 = global::hxDaedalus.data.math.Geom2D.getDirection(s1x, s1y, s2x, s2y, t3x, t3y);
					if (( ( ( side1 == 1 ) && ( side2 <= 0 ) ) || ( ( side1 <= 0 ) && ( side2 == 1 ) ) )) {
						return true;
					}
					
				}
				
				if (( ( ( side3_1 == 1 ) && ( side3_2 <= 0 ) ) || ( ( side3_1 <= 0 ) && ( side3_2 == 1 ) ) )) {
					side1 = global::hxDaedalus.data.math.Geom2D.getDirection(s1x, s1y, s2x, s2y, t3x, t3y);
					side2 = global::hxDaedalus.data.math.Geom2D.getDirection(s1x, s1y, s2x, s2y, t1x, t1y);
					if (( ( ( side1 == 1 ) && ( side2 <= 0 ) ) || ( ( side1 <= 0 ) && ( side2 == 1 ) ) )) {
						return true;
					}
					
				}
				
				return false;
			}
		}
		
		
		public static global::hxDaedalus.data.math.Point2D __circumcenter;
		
		public static bool isDelaunay(global::hxDaedalus.data.Edge edge) {
			global::hxDaedalus.data.Vertex vLeft = edge.get_originVertex();
			global::hxDaedalus.data.Vertex vRight = edge.get_destinationVertex();
			global::hxDaedalus.data.Vertex vCorner = edge.get_nextLeftEdge().get_destinationVertex();
			global::hxDaedalus.data.Vertex vOpposite = edge.get_nextRightEdge().get_destinationVertex();
			global::hxDaedalus.data.math.Geom2D.getCircumcenter(vCorner.get_pos().x, vCorner.get_pos().y, vLeft.get_pos().x, vLeft.get_pos().y, vRight.get_pos().x, vRight.get_pos().y, global::hxDaedalus.data.math.Geom2D.__circumcenter);
			double squaredRadius = ( ( (( vCorner.get_pos().x - global::hxDaedalus.data.math.Geom2D.__circumcenter.x )) * (( vCorner.get_pos().x - global::hxDaedalus.data.math.Geom2D.__circumcenter.x )) ) + ( (( vCorner.get_pos().y - global::hxDaedalus.data.math.Geom2D.__circumcenter.y )) * (( vCorner.get_pos().y - global::hxDaedalus.data.math.Geom2D.__circumcenter.y )) ) );
			double squaredDistance = ( ( (( vOpposite.get_pos().x - global::hxDaedalus.data.math.Geom2D.__circumcenter.x )) * (( vOpposite.get_pos().x - global::hxDaedalus.data.math.Geom2D.__circumcenter.x )) ) + ( (( vOpposite.get_pos().y - global::hxDaedalus.data.math.Geom2D.__circumcenter.y )) * (( vOpposite.get_pos().y - global::hxDaedalus.data.math.Geom2D.__circumcenter.y )) ) );
			return ( squaredDistance >= squaredRadius );
		}
		
		
		public static global::hxDaedalus.data.math.Point2D getCircumcenter(double x1, double y1, double x2, double y2, double x3, double y3, global::hxDaedalus.data.math.Point2D result) {
			unchecked {
				if (( result == null )) {
					result = new global::hxDaedalus.data.math.Point2D(default(global::haxe.lang.Null<double>), default(global::haxe.lang.Null<double>));
				}
				
				double m1 = ( (( x1 + x2 )) / 2 );
				double m2 = ( (( y1 + y2 )) / 2 );
				double m3 = ( (( x1 + x3 )) / 2 );
				double m4 = ( (( y1 + y3 )) / 2 );
				double t1 = ( (( ( ( m1 * (( x1 - x3 )) ) + ( (( m2 - m4 )) * (( y1 - y3 )) ) ) + ( m3 * (( x3 - x1 )) ) )) / (( ( ( x1 * (( y3 - y2 )) ) + ( x2 * (( y1 - y3 )) ) ) + ( x3 * (( y2 - y1 )) ) )) );
				result.x = ( m1 + ( t1 * (( y2 - y1 )) ) );
				result.y = ( m2 - ( t1 * (( x2 - x1 )) ) );
				return result;
			}
		}
		
		
		public static bool intersections2segments(double s1p1x, double s1p1y, double s1p2x, double s1p2y, double s2p1x, double s2p1y, double s2p2x, double s2p2y, global::hxDaedalus.data.math.Point2D posIntersection, global::HxArray<double> paramIntersection, global::haxe.lang.Null<bool> infiniteLineMode) {
			unchecked {
				bool infiniteLineMode1 = ( ( ! (infiniteLineMode.hasValue) ) ? (false) : ((infiniteLineMode).@value) );
				double t1 = ((double) (0) );
				double t2 = ((double) (0) );
				bool result = default(bool);
				double divisor = ( ( (( s1p1x - s1p2x )) * (( s2p1y - s2p2y )) ) + ( (( s1p2y - s1p1y )) * (( s2p1x - s2p2x )) ) );
				if (( divisor == 0 )) {
					result = false;
				}
				else {
					result = true;
					if (( (  ! (infiniteLineMode1)  || ( posIntersection != null ) ) || ( paramIntersection != null ) )) {
						t1 = ( (( ( ( ( s1p1x * (( s2p1y - s2p2y )) ) + ( s1p1y * (( s2p2x - s2p1x )) ) ) + ( s2p1x * s2p2y ) ) - ( s2p1y * s2p2x ) )) / divisor );
						t2 = ( (( ( ( ( s1p1x * (( s2p1y - s1p2y )) ) + ( s1p1y * (( s1p2x - s2p1x )) ) ) - ( s1p2x * s2p1y ) ) + ( s1p2y * s2p1x ) )) / divisor );
						if ((  ! (infiniteLineMode1)  &&  ! ((( ( ( ( 0 <= t1 ) && ( t1 <= 1 ) ) && ( 0 <= t2 ) ) && ( t2 <= 1 ) )))  )) {
							result = false;
						}
						
					}
					
				}
				
				if (result) {
					if (( posIntersection != null )) {
						posIntersection.x = ( s1p1x + ( t1 * (( s1p2x - s1p1x )) ) );
						posIntersection.y = ( s1p1y + ( t1 * (( s1p2y - s1p1y )) ) );
					}
					
					if (( paramIntersection != null )) {
						paramIntersection.push(t1);
						paramIntersection.push(t2);
					}
					
				}
				
				return result;
			}
		}
		
		
		public static bool intersections2edges(global::hxDaedalus.data.Edge edge1, global::hxDaedalus.data.Edge edge2, global::hxDaedalus.data.math.Point2D posIntersection, global::HxArray<double> paramIntersection, global::haxe.lang.Null<bool> infiniteLineMode) {
			bool infiniteLineMode1 = ( ( ! (infiniteLineMode.hasValue) ) ? (false) : ((infiniteLineMode).@value) );
			return global::hxDaedalus.data.math.Geom2D.intersections2segments(edge1.get_originVertex().get_pos().x, edge1.get_originVertex().get_pos().y, edge1.get_destinationVertex().get_pos().x, edge1.get_destinationVertex().get_pos().y, edge2.get_originVertex().get_pos().x, edge2.get_originVertex().get_pos().y, edge2.get_destinationVertex().get_pos().x, edge2.get_destinationVertex().get_pos().y, posIntersection, paramIntersection, new global::haxe.lang.Null<bool>(infiniteLineMode1, true));
		}
		
		
		public static bool isConvex(global::hxDaedalus.data.Edge edge) {
			unchecked {
				bool result = true;
				global::hxDaedalus.data.Edge eLeft = edge.get_nextLeftEdge().get_oppositeEdge();
				global::hxDaedalus.data.Vertex vRight = edge.get_nextRightEdge().get_destinationVertex();
				if (( global::hxDaedalus.data.math.Geom2D.getRelativePosition(vRight.get_pos().x, vRight.get_pos().y, eLeft) != -1 )) {
					result = false;
				}
				else {
					eLeft = edge.get_prevRightEdge();
					vRight = edge.get_prevLeftEdge().get_originVertex();
					if (( global::hxDaedalus.data.math.Geom2D.getRelativePosition(vRight.get_pos().x, vRight.get_pos().y, eLeft) != -1 )) {
						result = false;
					}
					
				}
				
				return result;
			}
		}
		
		
		public static void projectOrthogonaly(global::hxDaedalus.data.math.Point2D vertexPos, global::hxDaedalus.data.Edge edge) {
			unchecked {
				double a = edge.get_originVertex().get_pos().x;
				double b = edge.get_originVertex().get_pos().y;
				double c = edge.get_destinationVertex().get_pos().x;
				double d = edge.get_destinationVertex().get_pos().y;
				double e = vertexPos.x;
				double f = vertexPos.y;
				double t1 = ( (( ( ( ( ( ( ( ( a * a ) - ( a * c ) ) - ( a * e ) ) + ( b * b ) ) - ( b * d ) ) - ( b * f ) ) + ( c * e ) ) + ( d * f ) )) / (( ( ( ( ( ( a * a ) - ( ( 2 * a ) * c ) ) + ( b * b ) ) - ( ( 2 * b ) * d ) ) + ( c * c ) ) + ( d * d ) )) );
				vertexPos.x = ( a + ( t1 * (( c - a )) ) );
				vertexPos.y = ( b + ( t1 * (( d - b )) ) );
			}
		}
		
		
		public static bool intersections2Circles(double cx1, double cy1, double r1, double cx2, double cy2, double r2, global::HxArray<double> result) {
			unchecked {
				double distRadiusSQRD = ( ( (( cx2 - cx1 )) * (( cx2 - cx1 )) ) + ( (( cy2 - cy1 )) * (( cy2 - cy1 )) ) );
				if (( ( (( ( cx1 != cx2 ) || ( cy1 != cy2 ) )) && ( distRadiusSQRD <= ( (( r1 + r2 )) * (( r1 + r2 )) ) ) ) && ( distRadiusSQRD >= ( (( r1 - r2 )) * (( r1 - r2 )) ) ) )) {
					double transcendPart = global::System.Math.Sqrt(((double) (( (( ( (( r1 + r2 )) * (( r1 + r2 )) ) - distRadiusSQRD )) * (( distRadiusSQRD - ( (( r2 - r1 )) * (( r2 - r1 )) ) )) )) ));
					double xFirstPart = ( ( (( cx1 + cx2 )) / 2 ) + ( ( (( cx2 - cx1 )) * (( ( r1 * r1 ) - ( r2 * r2 ) )) ) / (( 2 * distRadiusSQRD )) ) );
					double yFirstPart = ( ( (( cy1 + cy2 )) / 2 ) + ( ( (( cy2 - cy1 )) * (( ( r1 * r1 ) - ( r2 * r2 ) )) ) / (( 2 * distRadiusSQRD )) ) );
					double xFactor = ( (( cy2 - cy1 )) / (( 2 * distRadiusSQRD )) );
					double yFactor = ( (( cx2 - cx1 )) / (( 2 * distRadiusSQRD )) );
					if (( result != null )) {
						{
							double f = ( xFirstPart + ( xFactor * transcendPart ) );
							result.push(f);
						}
						
						{
							double f1 = ( yFirstPart - ( yFactor * transcendPart ) );
							result.push(f1);
						}
						
						{
							double f2 = ( xFirstPart - ( xFactor * transcendPart ) );
							result.push(f2);
						}
						
						{
							double f3 = ( yFirstPart + ( yFactor * transcendPart ) );
							result.push(f3);
						}
						
					}
					
					return true;
				}
				else {
					return false;
				}
				
			}
		}
		
		
		public static bool intersectionsSegmentCircle(double p0x, double p0y, double p1x, double p1y, double cx, double cy, double r, global::HxArray<double> result) {
			unchecked {
				double p0xSQD = ( p0x * p0x );
				double p0ySQD = ( p0y * p0y );
				double a = ( ( ( ( ( ( p1y * p1y ) - ( ( 2 * p1y ) * p0y ) ) + p0ySQD ) + ( p1x * p1x ) ) - ( ( 2 * p1x ) * p0x ) ) + p0xSQD );
				double b = ( ( ( ( ( ( ( ( ( 2 * p0y ) * cy ) - ( 2 * p0xSQD ) ) + ( ( 2 * p1y ) * p0y ) ) - ( 2 * p0ySQD ) ) + ( ( 2 * p1x ) * p0x ) ) - ( ( 2 * p1x ) * cx ) ) + ( ( 2 * p0x ) * cx ) ) - ( ( 2 * p1y ) * cy ) );
				double c = ( ( ( ( ( ( p0ySQD + ( cy * cy ) ) + ( cx * cx ) ) - ( ( 2 * p0y ) * cy ) ) - ( ( 2 * p0x ) * cx ) ) + p0xSQD ) - ( r * r ) );
				double delta = ( ( b * b ) - ( ( 4 * a ) * c ) );
				double deltaSQRT = default(double);
				double t0 = default(double);
				double t1 = default(double);
				if (( delta < 0 )) {
					return false;
				}
				else if (( delta == 0 )) {
					t0 = (  - (b)  / (( 2 * a )) );
					if (( ( t0 < 0 ) || ( t0 > 1 ) )) {
						return false;
					}
					
					if (( result != null )) {
						{
							double f = ( p0x + ( t0 * (( p1x - p0x )) ) );
							result.push(f);
						}
						
						{
							double f1 = ( p0y + ( t0 * (( p1y - p0y )) ) );
							result.push(f1);
						}
						
						{
							double f2 = t0;
							result.push(f2);
						}
						
					}
					
					return true;
				}
				else {
					deltaSQRT = global::System.Math.Sqrt(((double) (delta) ));
					t0 = ( ((  - (b)  + deltaSQRT )) / (( 2 * a )) );
					t1 = ( ((  - (b)  - deltaSQRT )) / (( 2 * a )) );
					bool intersecting = false;
					if (( ( 0 <= t0 ) && ( t0 <= 1 ) )) {
						if (( result != null )) {
							{
								double f3 = ( p0x + ( t0 * (( p1x - p0x )) ) );
								result.push(f3);
							}
							
							{
								double f4 = ( p0y + ( t0 * (( p1y - p0y )) ) );
								result.push(f4);
							}
							
							{
								double f5 = t0;
								result.push(f5);
							}
							
						}
						
						intersecting = true;
					}
					
					if (( ( 0 <= t1 ) && ( t1 <= 1 ) )) {
						if (( result != null )) {
							{
								double f6 = ( p0x + ( t1 * (( p1x - p0x )) ) );
								result.push(f6);
							}
							
							{
								double f7 = ( p0y + ( t1 * (( p1y - p0y )) ) );
								result.push(f7);
							}
							
							{
								double f8 = t1;
								result.push(f8);
							}
							
						}
						
						intersecting = true;
					}
					
					return intersecting;
				}
				
			}
		}
		
		
		public static bool intersectionsLineCircle(double p0x, double p0y, double p1x, double p1y, double cx, double cy, double r, global::HxArray<double> result) {
			unchecked {
				double p0xSQD = ( p0x * p0x );
				double p0ySQD = ( p0y * p0y );
				double a = ( ( ( ( ( ( p1y * p1y ) - ( ( 2 * p1y ) * p0y ) ) + p0ySQD ) + ( p1x * p1x ) ) - ( ( 2 * p1x ) * p0x ) ) + p0xSQD );
				double b = ( ( ( ( ( ( ( ( ( 2 * p0y ) * cy ) - ( 2 * p0xSQD ) ) + ( ( 2 * p1y ) * p0y ) ) - ( 2 * p0ySQD ) ) + ( ( 2 * p1x ) * p0x ) ) - ( ( 2 * p1x ) * cx ) ) + ( ( 2 * p0x ) * cx ) ) - ( ( 2 * p1y ) * cy ) );
				double c = ( ( ( ( ( ( p0ySQD + ( cy * cy ) ) + ( cx * cx ) ) - ( ( 2 * p0y ) * cy ) ) - ( ( 2 * p0x ) * cx ) ) + p0xSQD ) - ( r * r ) );
				double delta = ( ( b * b ) - ( ( 4 * a ) * c ) );
				double deltaSQRT = default(double);
				double t0 = default(double);
				double t1 = default(double);
				if (( delta < 0 )) {
					return false;
				}
				else if (( delta == 0 )) {
					t0 = (  - (b)  / (( 2 * a )) );
					{
						{
							double f = ( p0x + ( t0 * (( p1x - p0x )) ) );
							result.push(f);
						}
						
						{
							double f1 = ( p0y + ( t0 * (( p1y - p0y )) ) );
							result.push(f1);
						}
						
						{
							double f2 = t0;
							result.push(f2);
						}
						
					}
					
				}
				else if (( delta > 0 )) {
					deltaSQRT = global::System.Math.Sqrt(((double) (delta) ));
					t0 = ( ((  - (b)  + deltaSQRT )) / (( 2 * a )) );
					t1 = ( ((  - (b)  - deltaSQRT )) / (( 2 * a )) );
					{
						{
							double f3 = ( p0x + ( t0 * (( p1x - p0x )) ) );
							result.push(f3);
						}
						
						{
							double f4 = ( p0y + ( t0 * (( p1y - p0y )) ) );
							result.push(f4);
						}
						
						{
							double f5 = t0;
							result.push(f5);
						}
						
						{
							double f6 = ( p0x + ( t1 * (( p1x - p0x )) ) );
							result.push(f6);
						}
						
						{
							double f7 = ( p0y + ( t1 * (( p1y - p0y )) ) );
							result.push(f7);
						}
						
						{
							double f8 = t1;
							result.push(f8);
						}
						
					}
					
				}
				
				return true;
			}
		}
		
		
		public static bool tangentsPointToCircle(double px, double py, double cx, double cy, double r, global::HxArray<double> result) {
			unchecked {
				double c2x = ( (( px + cx )) / 2 );
				double c2y = ( (( py + cy )) / 2 );
				double r2 = ( 0.5 * global::System.Math.Sqrt(((double) (( ( (( px - cx )) * (( px - cx )) ) + ( (( py - cy )) * (( py - cy )) ) )) )) );
				return global::hxDaedalus.data.math.Geom2D.intersections2Circles(c2x, c2y, r2, cx, cy, r, result);
			}
		}
		
		
		public static bool tangentsCrossCircleToCircle(double r, double c1x, double c1y, double c2x, double c2y, global::HxArray<double> result) {
			unchecked {
				double distance = global::System.Math.Sqrt(((double) (( ( (( c1x - c2x )) * (( c1x - c2x )) ) + ( (( c1y - c2y )) * (( c1y - c2y )) ) )) ));
				double radius = ( distance / 4 );
				double centerX = ( c1x + ( (( c2x - c1x )) / 4 ) );
				double centerY = ( c1y + ( (( c2y - c1y )) / 4 ) );
				if (global::hxDaedalus.data.math.Geom2D.intersections2Circles(c1x, c1y, r, centerX, centerY, radius, result)) {
					double t1x = result[0];
					double t1y = result[1];
					double t2x = result[2];
					double t2y = result[3];
					double midX = ( (( c1x + c2x )) / 2 );
					double midY = ( (( c1y + c2y )) / 2 );
					double dotProd = ( ( (( t1x - midX )) * (( c2y - c1y )) ) + ( (( t1y - midY )) * ((  - (c2x)  + c1x )) ) );
					double tproj = ( dotProd / (( distance * distance )) );
					double projx = ( midX + ( tproj * (( c2y - c1y )) ) );
					double projy = ( midY - ( tproj * (( c2x - c1x )) ) );
					double t4x = ( ( 2 * projx ) - t1x );
					double t4y = ( ( 2 * projy ) - t1y );
					double t3x = ( ( t4x + t2x ) - t1x );
					double t3y = ( ( t2y + t4y ) - t1y );
					{
						{
							double f = t3x;
							result.push(f);
						}
						
						{
							double f1 = t3y;
							result.push(f1);
						}
						
						{
							double f2 = t4x;
							result.push(f2);
						}
						
						{
							double f3 = t4y;
							result.push(f3);
						}
						
					}
					
					return true;
				}
				else {
					return false;
				}
				
			}
		}
		
		
		public static void tangentsParalCircleToCircle(double r, double c1x, double c1y, double c2x, double c2y, global::HxArray<double> result) {
			unchecked {
				double distance = global::System.Math.Sqrt(((double) (( ( (( c1x - c2x )) * (( c1x - c2x )) ) + ( (( c1y - c2y )) * (( c1y - c2y )) ) )) ));
				double t1x = ( c1x + ( ( r * (( c2y - c1y )) ) / distance ) );
				double t1y = ( c1y + ( ( r * ((  - (c2x)  + c1x )) ) / distance ) );
				double t2x = ( ( 2 * c1x ) - t1x );
				double t2y = ( ( 2 * c1y ) - t1y );
				double t3x = ( ( t2x + c2x ) - c1x );
				double t3y = ( ( t2y + c2y ) - c1y );
				double t4x = ( ( t1x + c2x ) - c1x );
				double t4y = ( ( t1y + c2y ) - c1y );
				{
					{
						double f = t1x;
						result.push(f);
					}
					
					{
						double f1 = t1y;
						result.push(f1);
					}
					
					{
						double f2 = t2x;
						result.push(f2);
					}
					
					{
						double f3 = t2y;
						result.push(f3);
					}
					
					{
						double f4 = t3x;
						result.push(f4);
					}
					
					{
						double f5 = t3y;
						result.push(f5);
					}
					
					{
						double f6 = t4x;
						result.push(f6);
					}
					
					{
						double f7 = t4y;
						result.push(f7);
					}
					
				}
				
			}
		}
		
		
		public static double distanceSquaredPointToLine(double px, double py, double ax, double ay, double bx, double @by) {
			double a_b_squaredLength = ( ( (( bx - ax )) * (( bx - ax )) ) + ( (( @by - ay )) * (( @by - ay )) ) );
			double dotProduct = ( ( (( px - ax )) * (( bx - ax )) ) + ( (( py - ay )) * (( @by - ay )) ) );
			double p_a_squaredLength = ( ( (( ax - px )) * (( ax - px )) ) + ( (( ay - py )) * (( ay - py )) ) );
			return ( p_a_squaredLength - ( ( dotProduct * dotProduct ) / a_b_squaredLength ) );
		}
		
		
		public static double distanceSquaredPointToSegment(double px, double py, double ax, double ay, double bx, double @by) {
			unchecked {
				double a_b_squaredLength = ( ( (( bx - ax )) * (( bx - ax )) ) + ( (( @by - ay )) * (( @by - ay )) ) );
				double dotProduct = ( (( ( (( px - ax )) * (( bx - ax )) ) + ( (( py - ay )) * (( @by - ay )) ) )) / a_b_squaredLength );
				if (( dotProduct < 0 )) {
					return ( ( (( px - ax )) * (( px - ax )) ) + ( (( py - ay )) * (( py - ay )) ) );
				}
				else if (( dotProduct <= 1 )) {
					double p_a_squaredLength = ( ( (( ax - px )) * (( ax - px )) ) + ( (( ay - py )) * (( ay - py )) ) );
					return ( p_a_squaredLength - ( ( dotProduct * dotProduct ) * a_b_squaredLength ) );
				}
				else {
					return ( ( (( px - bx )) * (( px - bx )) ) + ( (( py - @by )) * (( py - @by )) ) );
				}
				
			}
		}
		
		
		public static double distanceSquaredVertexToEdge(global::hxDaedalus.data.Vertex vertex, global::hxDaedalus.data.Edge edge) {
			return global::hxDaedalus.data.math.Geom2D.distanceSquaredPointToSegment(vertex.get_pos().x, vertex.get_pos().y, edge.get_originVertex().get_pos().x, edge.get_originVertex().get_pos().y, edge.get_destinationVertex().get_pos().x, edge.get_destinationVertex().get_pos().y);
		}
		
		
		public static double pathLength(global::HxArray<double> path) {
			unchecked {
				double sumDistance = 0.0;
				double fromX = path[0];
				double fromY = path[1];
				double nextX = default(double);
				double nextY = default(double);
				double x = default(double);
				double y = default(double);
				double distance = default(double);
				int i = 2;
				while (( i < path.length )) {
					nextX = path[i];
					nextY = path[( i + 1 )];
					x = ( nextX - fromX );
					y = ( nextY - fromY );
					distance = global::System.Math.Sqrt(((double) (( ( x * x ) + ( y * y ) )) ));
					sumDistance += distance;
					fromX = nextX;
					fromY = nextY;
					i += 2;
				}
				
				return sumDistance;
			}
		}
		
		
	}
}


